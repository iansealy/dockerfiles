diff -rc pine4.64/pine/adrbkcmd.c pine4.64.rules/pine/adrbkcmd.c
*** pine4.64/pine/adrbkcmd.c	Tue Sep 27 14:27:55 2005
--- pine4.64.rules/pine/adrbkcmd.c	Sat Oct 14 08:55:28 2006
***************
*** 3866,3871 ****
--- 3866,3873 ----
  	 * won't do anything, but will cause compose_mail to think there's
  	 * already a role so that it won't try to confirm the default.
  	 */
+ 	if (ps_global->role)
+ 	   fs_give((void **)&ps_global->role);
  	if(role)
  	  role = copy_action(role);
  	else{
***************
*** 3873,3878 ****
--- 3875,3881 ----
  	    memset((void *)role, 0, sizeof(*role));
  	    role->nick = cpystr("Default Role");
  	}
+ 	ps_global->role = cpystr(role->nick);
      }
  
      compose_mail(addr, fcc, role, NULL, NULL);
diff -rc pine4.64/pine/bldaddr.c pine4.64.rules/pine/bldaddr.c
*** pine4.64/pine/bldaddr.c	Tue Sep 27 14:27:55 2005
--- pine4.64.rules/pine/bldaddr.c	Sat Oct 14 08:55:28 2006
***************
*** 2306,2313 ****
  	    if(as.cur >= as.how_many_personals)
  	      pab->type |= GLOBAL;
  
! 	    pab->access = adrbk_access(pab);
! 
  	    /* global address books are forced readonly */
  	    if(pab->type & GLOBAL && pab->access != NoAccess)
  	      pab->access = ReadOnly;
--- 2306,2319 ----
  	    if(as.cur >= as.how_many_personals)
  	      pab->type |= GLOBAL;
  
! 	    if(ps_global->mail_stream && 
! 		ps_global->mail_stream->lock && (pab->type & REMOTE_VIA_IMAP)){
! 	      as.initialized = 0;
! 	      pab->access = NoAccess;
! 	    }
! 	    else{
! 	      pab->access = adrbk_access(pab);
! 	    }
  	    /* global address books are forced readonly */
  	    if(pab->type & GLOBAL && pab->access != NoAccess)
  	      pab->access = ReadOnly;
diff -rc pine4.64/pine/imap.c pine4.64.rules/pine/imap.c
*** pine4.64/pine/imap.c	Mon Sep 12 15:04:25 2005
--- pine4.64.rules/pine/imap.c	Mon Oct 16 12:28:14 2006
***************
*** 1014,1021 ****
--- 1014,1023 ----
  	    }
  	    else
  #endif /* _WINDOWS */
+ 	    ps_global->password = 1;
  	    rc = optionally_enter(user, q_line, 0, NETMAXUSER,
  				  prompt, NULL, help, &flags);
+ 	    ps_global->password = 0;
  	    ps_global->dont_use_init_cmds = save_dont_use;
  
  	    if(rc == 3) {
***************
*** 1199,1206 ****
--- 1201,1210 ----
  	  rc = os_login_dialog(mb, user, NETMAXUSER, pwd, NETMAXPASSWD, 0, 1);
  	else
  #endif
+ 	ps_global->password = 1;
          rc = optionally_enter(pwd, q_line, 0, NETMAXPASSWD,
  			      prompt, NULL, help, &flags);
+ 	ps_global->password = 0;
  	ps_global->dont_use_init_cmds = save_dont_use;
  
          if(rc == 3) {
diff -rc pine4.64/pine/init.c pine4.64.rules/pine/init.c
*** pine4.64/pine/init.c	Mon Sep 12 11:53:17 2005
--- pine4.64.rules/pine/init.c	Sat Oct 14 11:08:03 2006
***************
*** 218,223 ****
--- 218,253 ----
  
  CONF_TXT_T cf_text_folder_sort_rule[] =	"Sets presentation order of folder list entries. Choices: alphabetical,\n# alpha-with-dirs-last, alpha-with-dirs-first.\n# Default: \"alpha-with-directories-last\".";
  
+ CONF_TXT_T cf_text_compose_rules[] =	"Allows a user to set rules when composing messages.";
+ 
+ CONF_TXT_T cf_text_forward_rules[] =	"Allows a user to set rules when forwarding messages.";
+ 
+ CONF_TXT_T cf_text_reply_rules[] =	"Allows a user to set rules when replying messages.";
+ 
+ CONF_TXT_T cf_text_index_rules[] =	"Allows a user to supercede global index format variable in designated folders.";
+ 
+ CONF_TXT_T cf_text_key_def_rules[] =	"Allows a user to override keystrokes in certain screens.";
+ 
+ CONF_TXT_T cf_text_replace_rules[] =	"Allows a user to change the form a specify field in the index-format is \n# displayed.";
+ 
+ CONF_TXT_T cf_text_reply_indent_rules[] = "Allows a user to change the form a specify a reply-indent-string\n# based of rules.";
+ 
+ CONF_TXT_T cf_text_reply_leadin_rules[] =	"Allows a user to replace the reply-leadin message based on different parameters.";
+ 
+ CONF_TXT_T cf_text_reply_subject_rules[] =	"Allows a user to replace the subject of a message in a customs based way";
+ 
+ CONF_TXT_T cf_text_thread_displaystyle_rule[] = "Allows a user to specify the threading style of specific folders";
+ 
+ CONF_TXT_T cf_text_thread_indexstyle_rule[] = "Allows a user to specify the threading index style of specific folders";
+ 
+ CONF_TXT_T cf_text_save_rules[] =	"Allows a user to specify a save folder message for specific senders or folders.";
+ 
+ CONF_TXT_T cf_text_smtp_rules[] =	"Allows a user to specify a smtp server to be used when sending e-mail,\n# according to the rules specified here.";
+ 
+ CONF_TXT_T cf_text_sort_rules[] =	"Allows a user to specify the sort default order of a specific folder.";
+ 
+ CONF_TXT_T cf_text_startup_rules[] =	"Allows a user to specify the position of a highlighted message when opening a \n# folder.";
+ 
  CONF_TXT_T cf_text_character_set[] =	"Reflects capabilities of the display you have. Default: US-ASCII.\n# Typical alternatives include ISO-8859-x, (x is a number between 1 and 9).";
  
  CONF_TXT_T cf_text_editor[] =		"Specifies the program invoked by ^_ in the Composer,\n# or the \"enable-alternate-editor-implicitly\" feature.";
***************
*** 533,538 ****
--- 563,596 ----
  				cf_text_thread_exp_char},
  {"threading-lastreply-character",	0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
  				cf_text_thread_lastreply_char},
+ {"threading-display-style-rule",	0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_thread_displaystyle_rule},
+ {"threading-index-style-rule",		0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_thread_indexstyle_rule},
+ {"compose-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_compose_rules},
+ {"forward-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_forward_rules},
+ {"index-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_index_rules},
+ {"key-definition-rules",		0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
+ 				cf_text_key_def_rules},
+ {"replace-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_replace_rules},
+ {"reply-indent-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_reply_indent_rules},
+ {"reply-leadin-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_reply_leadin_rules},
+ {"reply-subject-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_reply_subject_rules},
+ {"save-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_save_rules},
+ {"smtp-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_smtp_rules},
+ {"sort-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_sort_rules},
+ {"startup-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
+ 				cf_text_startup_rules},
  {"character-set",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
  				cf_text_character_set},
  {"editor",				0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
***************
*** 1862,1867 ****
--- 1920,1937 ----
      set_current_val(&vars[V_POSTPONED_FOLDER], TRUE, TRUE);
      set_current_val(&vars[V_READ_MESSAGE_FOLDER], TRUE, TRUE);
      set_current_val(&vars[V_FORM_FOLDER], TRUE, TRUE);
+     set_current_val(&vars[V_COMPOSE_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_FORWARD_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_INDEX_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_KEY_RULES], FALSE, TRUE);
+     set_current_val(&vars[V_REPLACE_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_REPLY_INDENT_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_REPLY_LEADIN_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_RESUB_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_SAVE_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_SMTP_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_SORT_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_STARTUP_RULES], TRUE, TRUE);
      set_current_val(&vars[V_EDITOR], TRUE, TRUE);
      set_current_val(&vars[V_SPELLER], TRUE, TRUE);
      set_current_val(&vars[V_IMAGE_VIEWER], TRUE, TRUE);
***************
*** 2371,2376 ****
--- 2441,2448 ----
      cur_rule_value(&vars[V_GOTO_DEFAULT_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_THREAD_DISP_STYLE], TRUE, TRUE);
      cur_rule_value(&vars[V_THREAD_INDEX_STYLE], TRUE, TRUE);
+     cur_rule_value(&vars[V_THREAD_DISP_STYLE_RULES], TRUE, TRUE);
+     cur_rule_value(&vars[V_THREAD_INDEX_STYLE_RULES], TRUE, TRUE);
  
      set_current_val(&vars[V_THREAD_MORE_CHAR], TRUE, TRUE);
      if(VAR_THREAD_MORE_CHAR[0] && VAR_THREAD_MORE_CHAR[1]){
***************
*** 2424,2429 ****
--- 2496,2502 ----
      if(VAR_INIT_CMD_LIST && VAR_INIT_CMD_LIST[0] && VAR_INIT_CMD_LIST[0][0])
          process_init_cmds(ps, VAR_INIT_CMD_LIST);
  
+     create_rule_list();
  #ifdef	_WINDOWS
      mswin_set_quit_confirm (F_OFF(F_QUIT_WO_CONFIRM, ps_global));
      if(ps_global->update_registry != UREG_NEVER_SET){
***************
*** 2826,2831 ****
--- 2899,2906 ----
  	 F_FORCE_LOW_SPEED, h_config_force_low_speed, PREF_OS_LWSD},
  	{"auto-move-read-msgs",
  	 F_AUTO_READ_MSGS, h_config_auto_read_msgs, PREF_MISC},
+ 	{"auto-move-read-msgs-using-rules",
+ 	 F_AUTO_READ_MSGS_RULES, h_config_auto_read_msgs_rules, PREF_MISC},
  	{"auto-unzoom-after-apply",
  	 F_AUTO_UNZOOM, h_config_auto_unzoom, PREF_MISC},
  	{"auto-zoom-after-select",
diff -rc pine4.64/pine/mailcmd.c pine4.64.rules/pine/mailcmd.c
*** pine4.64/pine/mailcmd.c	Mon Sep 12 15:04:25 2005
--- pine4.64.rules/pine/mailcmd.c	Sat Oct 14 08:55:29 2006
***************
*** 119,124 ****
--- 119,129 ----
  int	  read_msg_prompt PROTO((long, char *));
  char	 *move_read_incoming PROTO((MAILSTREAM *, CONTEXT_S *, char *,
  				    char **, char *));
+ char	 *move_read_msgs_using_rules PROTO((MAILSTREAM *, char *, char *));
+ unsigned  get_perfolder_startup_rule PROTO((MAILSTREAM *, int, char *));
+ void	  setup_threading_index_style PROTO(());
+ int	  find_startup_position PROTO((int, MAILSTREAM *, long));
+ char	 *get_folder_to_save PROTO((MAILSTREAM *, long, char *));
  void	  cross_delete_crossposts PROTO((MAILSTREAM *));
  void      menu_clear_cmd_binding PROTO((struct key_menu *, int));
  int	  update_folder_spec PROTO((char *, char *));
***************
*** 141,146 ****
--- 146,154 ----
  #define SV_FOR_FILT		0x2
  #define SV_FIX_DELS		0x4
  
+ static  MAILSTREAM *saved_stream;
+ static  unsigned long rule_curpos = 0L;
+ 
  typedef struct append_package {
    MAILSTREAM *stream;
    char *flags;
***************
*** 2931,2936 ****
--- 2939,2945 ----
      if(agg && !pseudo_selected(msgmap))
        return;
  
+     saved_stream = stream;		/* ugly hack! */
      state->ugly_consider_advancing_bit = 0;
      if(F_OFF(F_SAVE_PARTIAL_WO_CONFIRM, state)
         && msgno_any_deletedparts(stream, msgmap)
***************
*** 3119,3124 ****
--- 3128,3136 ----
  		role->nick = cpystr("Default Role");
  	    }
  
+ 	    if(state->role)
+ 	      fs_give((void **)&state->role);
+ 	    state->role = cpystr(role->nick); /* remember the role */
  	    state->redrawer = NULL;
  	    switch(action){
  	      case 'c':
***************
*** 3178,3184 ****
  {
      static char	      folder[MAILTMPLEN+1] = {'\0'};
      static CONTEXT_S *last_context = NULL;
!     int		      rc, n, flags, last_rc = 0, saveable_count = 0, done = 0;
      int               context_was_set, delindex;
      char	      prompt[MAX_SCREEN_COLS+1], *p, expanded[MAILTMPLEN];
      char              *buf = tmp_20k_buf;
--- 3190,3196 ----
  {
      static char	      folder[MAILTMPLEN+1] = {'\0'};
      static CONTEXT_S *last_context = NULL;
!     int		      rc, n=0, flags, last_rc = 0, saveable_count = 0, done = 0;
      int               context_was_set, delindex;
      char	      prompt[MAX_SCREEN_COLS+1], *p, expanded[MAILTMPLEN];
      char              *buf = tmp_20k_buf;
***************
*** 3187,3192 ****
--- 3199,3207 ----
      char             *deltext = NULL;
      CONTEXT_S	     *tc;
      ESCKEY_S	      ekey[9];
+     RULE_RESULT      *rule;
+ 
+     saved_stream  = state->mail_stream;
  
      if(!cntxt)
        panic("no context ptr in save_prompt");
***************
*** 3217,3222 ****
--- 3232,3244 ----
  	  return(0);
      }
  
+     if (rule = get_result_rule(V_SAVE_RULES, FOR_SAVE, env)){
+        strncpy(folder,rule->result,sizeof(folder)-1);
+        folder[sizeof(folder)-1] = '\0';
+        if (rule->result)
+ 	   fs_give((void **)&rule->result);
+        fs_give((void **)&rule);
+     }
  
      /* how many context's can be saved to... */
      for(tc = state->context_list; tc; tc = tc->next)
***************
*** 4137,4143 ****
  	      *date = '\0';
  
  	    rv = save_fetch_append(stream, mn_m2raw(msgmap, i),
! 				   NULL, save_stream, save_folder, context,
  				   mc ? mc->rfc822_size : 0L, flags, date, so);
  
  	    if(sp_expunge_count(stream))
--- 4159,4165 ----
  	      *date = '\0';
  
  	    rv = save_fetch_append(stream, mn_m2raw(msgmap, i),
! 				   NULL, save_stream, folder, context,
  				   mc ? mc->rfc822_size : 0L, flags, date, so);
  
  	    if(sp_expunge_count(stream))
***************
*** 7325,7330 ****
--- 7347,7526 ----
      return(FALSE);
  }
  
+ void
+ setup_threading_index_style()
+ {
+   RULE_RESULT *rule;
+   NAMEVAL_S *v;
+   int i;
+ 
+   rule = get_result_rule(V_THREAD_INDEX_STYLE_RULES, FOR_THREAD, NULL);
+   if (rule || ps_global->VAR_THREAD_INDEX_STYLE){
+      for(i = 0; v = thread_index_styles(i); i++)
+         if(!strucmp(rule ? rule->result : ps_global->VAR_THREAD_INDEX_STYLE, 
+ 		    rule ? (v ? v->name : "" ) : S_OR_L(v))){
+               ps_global->thread_index_style = v->value;
+               break;
+         }
+      if (rule){
+ 	if (rule->result)
+ 	   fs_give((void **)&rule->result);
+ 	fs_give((void **)&rule);
+      }
+   }
+ }
+ 
+ find_startup_position(rule, m, pc)
+ int rule;
+ MAILSTREAM *m;
+ long pc;
+ {
+   long n;
+     switch(rule){
+ 	      /*
+ 	       * For news in incoming collection we're doing the same thing
+ 	       * for first-unseen and first-recent. In both those cases you
+ 	       * get first-unseen if FAKE_NEW is off and first-recent if
+ 	       * FAKE_NEW is on. If FAKE_NEW is on, first unseen is the
+ 	       * same as first recent because all recent msgs are unseen
+ 	       * and all unrecent msgs are seen (see pine_mail_open).
+ 	       */
+ 	      case IS_FIRST_UNSEEN:
+ first_unseen:
+ 		mn_set_cur(ps_global->msgmap,
+ 			(sp_first_unseen(m)
+ 			 && mn_get_sort(ps_global->msgmap) == SortArrival
+ 			 && !mn_get_revsort(ps_global->msgmap)
+ 			 && !get_lflag(ps_global->mail_stream, NULL,
+ 				       sp_first_unseen(m), MN_EXLD)
+ 			 && (n = mn_raw2m(ps_global->msgmap, 
+ 					  sp_first_unseen(m))))
+ 			   ? n
+ 			   : first_sorted_flagged(F_UNSEEN | F_UNDEL, m, pc,
+ 					      THREADING() ? 0 : FSF_SKIP_CHID));
+ 		break;
+ 
+ 	      case IS_FIRST_RECENT:
+ first_recent:
+ 		/*
+ 		 * We could really use recent for news but this is the way
+ 		 * it has always worked, so we'll leave it. That is, if
+ 		 * the FAKE_NEW feature is on, recent and unseen are
+ 		 * equivalent, so it doesn't matter. If the feature isn't
+ 		 * on, all the undeleted messages are unseen and we start
+ 		 * at the first one. User controls with the FAKE_NEW feature.
+ 		 */
+ 		if(IS_NEWS(ps_global->mail_stream)){
+ 		    mn_set_cur(ps_global->msgmap,
+ 			       first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
+ 					       THREADING() ? 0 : FSF_SKIP_CHID));
+ 		}
+ 		else{
+ 		    mn_set_cur(ps_global->msgmap,
+ 			       first_sorted_flagged(F_RECENT | F_UNSEEN
+ 						    | F_UNDEL,
+ 						    m, pc,
+ 					      THREADING() ? 0 : FSF_SKIP_CHID));
+ 		}
+ 		break;
+ 
+ 	      case IS_FIRST_IMPORTANT:
+ 		mn_set_cur(ps_global->msgmap,
+ 			   first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+ 					      THREADING() ? 0 : FSF_SKIP_CHID));
+ 		break;
+ 
+ 	      case IS_FIRST_IMPORTANT_OR_UNSEEN:
+ 
+ 		if(IS_NEWS(ps_global->mail_stream))
+ 		  goto first_unseen;
+ 
+ 		{
+ 		    MsgNo flagged, first_unseen;
+ 
+ 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+ 					       THREADING() ? 0 : FSF_SKIP_CHID);
+ 		    first_unseen = (sp_first_unseen(m)
+ 			     && mn_get_sort(ps_global->msgmap) == SortArrival
+ 			     && !mn_get_revsort(ps_global->msgmap)
+ 			     && !get_lflag(ps_global->mail_stream, NULL,
+ 					   sp_first_unseen(m), MN_EXLD)
+ 			     && (n = mn_raw2m(ps_global->msgmap, 
+ 					      sp_first_unseen(m))))
+ 				? n
+ 				: first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
+ 					       THREADING() ? 0 : FSF_SKIP_CHID);
+ 		    mn_set_cur(ps_global->msgmap,
+ 			  (MsgNo) min((int) flagged, (int) first_unseen));
+ 
+ 		}
+ 
+ 		break;
+ 
+ 	      case IS_FIRST_IMPORTANT_OR_RECENT:
+ 
+ 		if(IS_NEWS(ps_global->mail_stream))
+ 		  goto first_recent;
+ 
+ 		{
+ 		    MsgNo flagged, first_recent;
+ 
+ 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+ 					       THREADING() ? 0 : FSF_SKIP_CHID);
+ 		    first_recent = first_sorted_flagged(F_RECENT | F_UNSEEN
+ 							| F_UNDEL,
+ 							m, pc,
+ 					       THREADING() ? 0 : FSF_SKIP_CHID);
+ 		    mn_set_cur(ps_global->msgmap,
+ 			      (MsgNo) min((int) flagged, (int) first_recent));
+ 		}
+ 
+ 		break;
+ 
+ 	      case IS_FIRST:
+ 		mn_set_cur(ps_global->msgmap,
+ 			   first_sorted_flagged(F_UNDEL, m, pc,
+ 					      THREADING() ? 0 : FSF_SKIP_CHID));
+ 		break;
+ 
+ 	      case IS_LAST:
+ 		mn_set_cur(ps_global->msgmap,
+ 			   first_sorted_flagged(F_UNDEL, m, pc,
+ 			         FSF_LAST | (THREADING() ? 0 : FSF_SKIP_CHID)));
+ 		break;
+ 
+ 	      default:
+ 		panic("Unexpected incoming startup case");
+ 		break;
+ 
+     }
+ }
+ 
+ unsigned
+ get_perfolder_startup_rule(stream, rule_type, folder)
+   MAILSTREAM *stream;
+   int	      rule_type;
+   char	     *folder;
+ {
+     unsigned	startup_rule;
+     char        *rule_result;
+      
+     startup_rule =  reset_startup_rule(stream);
+     rule_result = get_rule_result(FOR_STARTUP, folder, rule_type);
+     if (rule_result && *rule_result){
+        int        i;
+        NAMEVAL_S *v;
+ 
+        for(i = 0; v = incoming_startup_rules(i); i++)
+           if(!strucmp(rule_result, v->name)){
+              startup_rule = v->value;
+              break;
+           }
+        fs_give((void **)&rule_result);  
+      }
+    return startup_rule;
+ }
+ 
  
  /*----------------------------------------------------------------------
      Actually attempt to open given folder 
***************
*** 7693,7698 ****
--- 7889,7895 ----
  		sizeof(ps_global->cur_folder)-1);
  	ps_global->cur_folder[sizeof(ps_global->cur_folder)-1] = '\0';
  	ps_global->context_current = ps_global->context_list;
+ 	setup_threading_index_style();
  	reset_index_format();
  	clear_index_cache();
          /* MUST sort before restoring msgno! */
***************
*** 8002,8007 ****
--- 8199,8205 ----
  
      clear_index_cache();
      reset_index_format();
+     setup_threading_index_style();
  
      /*
       * Start news reading with messages the user's marked deleted
***************
*** 8021,8026 ****
--- 8219,8231 ----
      if(!sp_flagged(ps_global->mail_stream, SP_FILTERED))
        process_filter_patterns(ps_global->mail_stream, ps_global->msgmap, 0L);
  
+     if(!(rflags & SP_MATCH) || !(rflags & SP_LOCKED))
+       reset_sort_order(SRT_VRB);
+     else if(sp_new_mail_count(ps_global->mail_stream) > 0L
+ 	    || sp_unsorted_newmail(ps_global->mail_stream)
+ 	    || sp_need_to_rethread(ps_global->mail_stream))
+       refresh_sort(ps_global->mail_stream, ps_global->msgmap, SRT_NON);
+ 
      q_status_message6(SM_ORDER, 0, 4,
  		    "%.20s \"%.200s\" opened with %.20s message%.20s%.20s%.20s",
  			IS_NEWS(ps_global->mail_stream)
***************
*** 8038,8051 ****
      mswin_settitle(pretty_fn(newfolder));
  #endif
  
-     if(!(rflags & SP_MATCH) || !(rflags & SP_LOCKED))
-       reset_sort_order(SRT_VRB);
-     else if(sp_new_mail_count(ps_global->mail_stream) > 0L
- 	    || sp_unsorted_newmail(ps_global->mail_stream)
- 	    || sp_need_to_rethread(ps_global->mail_stream))
-       refresh_sort(ps_global->mail_stream, ps_global->msgmap, SRT_NON);
- 
- 
      /*
       * Set current message number when re-opening Stay-Open or
       * cached folders.
--- 8243,8248 ----
***************
*** 8109,8115 ****
  
      if(!cur_already_set && mn_get_total(ps_global->msgmap) > 0L){
  
! 	perfolder_startup_rule = reset_startup_rule(ps_global->mail_stream);
  
  	if(ps_global->start_entry > 0){
  	    mn_set_cur(ps_global->msgmap, mn_get_revsort(ps_global->msgmap)
--- 8306,8315 ----
  
      if(!cur_already_set && mn_get_total(ps_global->msgmap) > 0L){
  
! 	perfolder_startup_rule = get_perfolder_startup_rule(ps_global->mail_stream,
!                                        V_STARTUP_RULES, newfolder);
! 
! 	reset_startup_rule(ps_global->mail_stream);
  
  	if(ps_global->start_entry > 0){
  	    mn_set_cur(ps_global->msgmap, mn_get_revsort(ps_global->msgmap)
***************
*** 8131,8254 ****
  	    else
  	      use_this_startup_rule = ps_global->inc_startup_rule;
  
! 	    switch(use_this_startup_rule){
! 	      /*
! 	       * For news in incoming collection we're doing the same thing
! 	       * for first-unseen and first-recent. In both those cases you
! 	       * get first-unseen if FAKE_NEW is off and first-recent if
! 	       * FAKE_NEW is on. If FAKE_NEW is on, first unseen is the
! 	       * same as first recent because all recent msgs are unseen
! 	       * and all unrecent msgs are seen (see pine_mail_open).
! 	       */
! 	      case IS_FIRST_UNSEEN:
! first_unseen:
! 		mn_set_cur(ps_global->msgmap,
! 			(sp_first_unseen(m)
! 			 && mn_get_sort(ps_global->msgmap) == SortArrival
! 			 && !mn_get_revsort(ps_global->msgmap)
! 			 && !get_lflag(ps_global->mail_stream, NULL,
! 				       sp_first_unseen(m), MN_EXLD)
! 			 && (n = mn_raw2m(ps_global->msgmap, 
! 					  sp_first_unseen(m))))
! 			   ? n
! 			   : first_sorted_flagged(F_UNSEEN | F_UNDEL, m, pc,
! 					      THREADING() ? 0 : FSF_SKIP_CHID));
! 		break;
! 
! 	      case IS_FIRST_RECENT:
! first_recent:
! 		/*
! 		 * We could really use recent for news but this is the way
! 		 * it has always worked, so we'll leave it. That is, if
! 		 * the FAKE_NEW feature is on, recent and unseen are
! 		 * equivalent, so it doesn't matter. If the feature isn't
! 		 * on, all the undeleted messages are unseen and we start
! 		 * at the first one. User controls with the FAKE_NEW feature.
! 		 */
! 		if(IS_NEWS(ps_global->mail_stream)){
! 		    mn_set_cur(ps_global->msgmap,
! 			       first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID));
! 		}
! 		else{
! 		    mn_set_cur(ps_global->msgmap,
! 			       first_sorted_flagged(F_RECENT | F_UNSEEN
! 						    | F_UNDEL,
! 						    m, pc,
! 					      THREADING() ? 0 : FSF_SKIP_CHID));
! 		}
! 		break;
! 
! 	      case IS_FIRST_IMPORTANT:
! 		mn_set_cur(ps_global->msgmap,
! 			   first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
! 					      THREADING() ? 0 : FSF_SKIP_CHID));
! 		break;
! 
! 	      case IS_FIRST_IMPORTANT_OR_UNSEEN:
! 
! 		if(IS_NEWS(ps_global->mail_stream))
! 		  goto first_unseen;
! 
! 		{
! 		    MsgNo flagged, first_unseen;
! 
! 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    first_unseen = (sp_first_unseen(m)
! 			     && mn_get_sort(ps_global->msgmap) == SortArrival
! 			     && !mn_get_revsort(ps_global->msgmap)
! 			     && !get_lflag(ps_global->mail_stream, NULL,
! 					   sp_first_unseen(m), MN_EXLD)
! 			     && (n = mn_raw2m(ps_global->msgmap, 
! 					      sp_first_unseen(m))))
! 				? n
! 				: first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    mn_set_cur(ps_global->msgmap,
! 			  (MsgNo) min((int) flagged, (int) first_unseen));
! 
! 		}
! 
! 		break;
! 
! 	      case IS_FIRST_IMPORTANT_OR_RECENT:
! 
! 		if(IS_NEWS(ps_global->mail_stream))
! 		  goto first_recent;
! 
! 		{
! 		    MsgNo flagged, first_recent;
! 
! 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    first_recent = first_sorted_flagged(F_RECENT | F_UNSEEN
! 							| F_UNDEL,
! 							m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    mn_set_cur(ps_global->msgmap,
! 			      (MsgNo) min((int) flagged, (int) first_recent));
! 		}
  
- 		break;
- 
- 	      case IS_FIRST:
- 		mn_set_cur(ps_global->msgmap,
- 			   first_sorted_flagged(F_UNDEL, m, pc,
- 					      THREADING() ? 0 : FSF_SKIP_CHID));
- 		break;
- 
- 	      case IS_LAST:
- 		mn_set_cur(ps_global->msgmap,
- 			   first_sorted_flagged(F_UNDEL, m, pc,
- 			         FSF_LAST | (THREADING() ? 0 : FSF_SKIP_CHID)));
- 		break;
- 
- 	      default:
- 		panic("Unexpected incoming startup case");
- 		break;
- 
- 	    }
  	}
  	else if(IS_NEWS(ps_global->mail_stream)){
  	    /*
--- 8331,8338 ----
  	    else
  	      use_this_startup_rule = ps_global->inc_startup_rule;
  
! 	    find_startup_position(use_this_startup_rule, m, pc);
  
  	}
  	else if(IS_NEWS(ps_global->mail_stream)){
  	    /*
***************
*** 8286,8293 ****
      PAT_STATE     pstate;
      PAT_S        *pat;
      int           we_set_it = 0;
  
!     if(ps_global->mail_stream && nonempty_patterns(rflags, &pstate)){
  	for(pat = first_pattern(&pstate); pat; pat = next_pattern(&pstate)){
  	    if(match_pattern(pat->patgrp, ps_global->mail_stream, NULL,
  			     NULL, NULL, SO_NOSERVER|SE_NOPREFETCH))
--- 8370,8384 ----
      PAT_STATE     pstate;
      PAT_S        *pat;
      int           we_set_it = 0;
+     char *rule;
  
!    if (rule = get_rule_result(FOR_INDEX, ps_global->cur_folder, V_INDEX_RULES)){
!       init_index_format(rule, &ps_global->index_disp_format);
!       fs_give((void **)&rule);
!       return;
!    }
! 
!    if(ps_global->mail_stream && nonempty_patterns(rflags, &pstate)){
  	for(pat = first_pattern(&pstate); pat; pat = next_pattern(&pstate)){
  	    if(match_pattern(pat->patgrp, ps_global->mail_stream, NULL,
  			     NULL, NULL, SO_NOSERVER|SE_NOPREFETCH))
***************
*** 8317,8323 ****
      PAT_S        *pat;
      SortOrder	  the_sort_order;
      int           sort_is_rev;
! 
      /* set default order */
      the_sort_order = ps_global->def_sort;
      sort_is_rev    = ps_global->def_sort_rev;
--- 8408,8428 ----
      PAT_S        *pat;
      SortOrder	  the_sort_order;
      int           sort_is_rev;
!     char       *rule_result;
!     SortOrder   new_sort = EndofList;
!     int		is_rev;
! 
!    rule_result = get_rule_result(FOR_SORT, ps_global->cur_folder, V_SORT_RULES);
!    if (rule_result && *rule_result){
!       new_sort  = (SortOrder) translate(rule_result, 1);
!       is_rev    = (SortOrder) translate(rule_result, 0) == EndofList ? 0 : 1;
!       fs_give((void **)&rule_result);
!    }
!    if (new_sort != EndofList){
!        the_sort_order = new_sort;
!        sort_is_rev    = is_rev;
!    }
!    else{
      /* set default order */
      the_sort_order = ps_global->def_sort;
      sort_is_rev    = ps_global->def_sort_rev;
***************
*** 8335,8341 ****
  	    sort_is_rev    = pat->action->revsort;
  	}
      }
! 
      sort_folder(ps_global->mail_stream, ps_global->msgmap,
  		the_sort_order, sort_is_rev, flags);
  }
--- 8440,8446 ----
  	    sort_is_rev    = pat->action->revsort;
  	}
      }
!    }
      sort_folder(ps_global->mail_stream, ps_global->msgmap,
  		the_sort_order, sort_is_rev, flags);
  }
***************
*** 8479,8487 ****
  	    /* Save read messages? */
  	    if(VAR_READ_MESSAGE_FOLDER && VAR_READ_MESSAGE_FOLDER[0]
  	       && sp_flagged(stream, SP_INBOX)
! 	       && (seen_not_del = count_flagged(stream, F_SEEN | F_UNDEL))){
  
  		if(F_ON(F_AUTO_READ_MSGS,ps_global)
  		   || read_msg_prompt(seen_not_del, VAR_READ_MESSAGE_FOLDER))
  		  /* move inbox's read messages */
  		  moved_msg = move_read_msgs(stream, VAR_READ_MESSAGE_FOLDER,
--- 8584,8594 ----
  	    /* Save read messages? */
  	    if(VAR_READ_MESSAGE_FOLDER && VAR_READ_MESSAGE_FOLDER[0]
  	       && sp_flagged(stream, SP_INBOX)
! 	       && (F_ON(F_AUTO_READ_MSGS_RULES, ps_global) ||
! 	          (seen_not_del = count_flagged(stream, F_SEEN | F_UNDEL)))){
  
  		if(F_ON(F_AUTO_READ_MSGS,ps_global)
+ 		   || F_ON(F_AUTO_READ_MSGS_RULES, ps_global)
  		   || read_msg_prompt(seen_not_del, VAR_READ_MESSAGE_FOLDER))
  		  /* move inbox's read messages */
  		  moved_msg = move_read_msgs(stream, VAR_READ_MESSAGE_FOLDER,
***************
*** 10136,10141 ****
--- 10243,10251 ----
      char	  *bufp = NULL;
      MESSAGECACHE *mc;
  
+     if (F_ON(F_AUTO_READ_MSGS_RULES, ps_global))
+      return move_read_msgs_using_rules(stream, dstfldr, buf);
+ 
      if(!is_absolute_path(dstfldr)
         && !(save_context = default_save_context(ps_global->context_list)))
        save_context = ps_global->context_list;
***************
*** 10177,10184 ****
  	sprintf(buf, "Moving %s read message%s to \"%.45s\"",
  		comatose(searched), plural(searched), dstfldr);
  	we_cancel = busy_alarm(1, buf, NULL, 1);
! 	if(save(ps_global, stream, save_context, dstfldr, msgmap,
! 		SV_DELETE | SV_FIX_DELS) == searched)
  	  strncpy(bufp = buf + 1, "Moved", 5); /* change Moving to Moved */
  
  	mn_give(&msgmap);
--- 10287,10295 ----
  	sprintf(buf, "Moving %s read message%s to \"%.45s\"",
  		comatose(searched), plural(searched), dstfldr);
  	we_cancel = busy_alarm(1, buf, NULL, 1);
! 	ps_global->exiting = 1;
! 	if((save(ps_global, stream, save_context, dstfldr, msgmap,
! 		SV_DELETE | SV_FIX_DELS) == searched))
  	  strncpy(bufp = buf + 1, "Moved", 5); /* change Moving to Moved */
  
  	mn_give(&msgmap);
***************
*** 10189,10194 ****
--- 10300,10441 ----
      return(bufp);
  }
  
+ char *
+ move_read_msgs_using_rules(stream, dstfldr,buf)
+     MAILSTREAM *stream;
+     char       *dstfldr;
+     char       *buf;
+ {
+     CONTEXT_S  *save_context = NULL;
+     char **folder_to_save = NULL;
+     int  num, we_cancel;
+     long i, j, success, nmsgs = 0L;
+     MSGNO_S *msgmap = NULL;
+ 
+     saved_stream = stream;		/* horrible hack! */
+     if(!is_absolute_path(dstfldr)
+        && !(save_context = default_save_context(ps_global->context_list)))
+        save_context = ps_global->context_list;
+ 
+     folder_to_save = (char **)fs_get((stream->nmsgs + 1)*sizeof(char *));
+     folder_to_save[0] = NULL;
+     mn_init(&msgmap, stream->nmsgs);  
+     for (i = 1L; i <= stream->nmsgs ; i++){
+ 	set_lflag(stream, msgmap, i, MN_SLCT, 0);
+         folder_to_save[i] = get_lflag(stream, NULL, i, MN_EXLD)
+ 			    ? NULL : get_folder_to_save(stream, i, dstfldr);
+     }
+     for (i = 1L; i <= stream->nmsgs; i++){
+ 	num = 0;
+         if (folder_to_save[i]){
+ 	   mn_init(&msgmap, stream->nmsgs);  
+            for (j = i; j <= stream->nmsgs ; j++){
+         	if (folder_to_save[j]){
+                    if (!strcmp(folder_to_save[i], folder_to_save[j])){
+                         set_lflag(stream, msgmap, j, MN_SLCT, 1);
+                         num++;
+                         if (j != i)
+                            fs_give((void **)&folder_to_save[j]);
+                    }
+                  }
+            }
+            pseudo_selected(msgmap);
+            sprintf(buf, "Moving %s read message%s to \"%.45s\"",
+            	      comatose(num), plural(num), folder_to_save[i]);
+            we_cancel = busy_alarm(1, buf, NULL, 1);
+            ps_global->exiting = 1;
+            if(success = save(ps_global, stream,save_context, folder_to_save[i],
+                  		msgmap, SV_DELETE | SV_FIX_DELS))
+            nmsgs += success;
+            if(we_cancel)
+              cancel_busy_alarm(success ? 0 : -1);
+            for (j = i; j <= stream->nmsgs ; j++)
+                set_lflag(stream, msgmap, j, MN_SLCT, 0);
+            fs_give((void **)&folder_to_save[i]);
+ 	   mn_give(&msgmap);
+         }
+     }
+     ps_global->exiting = 0; /* useful if we call from aggregate operations */
+     sprintf(buf, "Moved automatically %s message%s",
+ 		comatose(nmsgs), plural(nmsgs));
+     if (folder_to_save)
+         fs_give((void **)folder_to_save);
+     rule_curpos = 0L;
+     return buf;
+ }
+ 
+ unsigned long
+ rules_cursor_pos(stream)
+   MAILSTREAM *stream;
+ {
+   MSGNO_S *msgmap = sp_msgmap(stream);
+   return rule_curpos != 0L ? rule_curpos : mn_m2raw(msgmap,mn_get_cur(msgmap));
+ }
+ 
+ 
+ MAILSTREAM *
+ find_open_stream()
+ {
+  return saved_stream;
+ }
+ 
+ char *
+ get_folder_to_save(stream, i, dstfldr)
+   MAILSTREAM *stream;
+   long  i;
+   char  *dstfldr;
+ {
+     MESSAGECACHE *mc = NULL;
+     RULE_RESULT *rule;
+     MSGNO_S *msgmap = NULL;
+     char *folder_to_save = NULL, *save_folder = NULL;
+     int n;
+     long msgno;
+ 
+     /* The plan is as follows: Select each message of the folder. We
+      * need to set the cursor correctly so that iFlag gets the value
+      * correctly too, otherwise iFlag will get the value of the position
+      * of the cursor. After that we need to look for a rule that applies
+      * to the message and get the saving folder. If we get a saving folder,
+      * and we used the _FLAG_ token, use that folder, if no
+      * _FLAG_ token was used, move only if seen and not deleted, to the
+      * folder specified in the saving rule. If we did not get a saving
+      * folder from the rule, just save in the default folder.
+      */
+ 
+     mn_init(&msgmap, stream->nmsgs);
+     rule_curpos = i;
+     msgno = mn_m2raw(msgmap, i);
+     if (msgno > 0L){
+ 	mc = mail_elt(stream, msgno);
+ 	rule = (RULE_RESULT *)
+             get_result_rule(V_SAVE_RULES, FOR_SAVE, mc->private.msg.env);
+ 	if (rule){
+ 	    folder_to_save = cpystr(rule->result);
+ 	    n = rule->number;
+ 	    fs_give((void **)&rule->result);
+ 	    fs_give((void **)&rule);
+         }
+     }
+               
+     if (folder_to_save && *folder_to_save){
+ 	RULELIST *list = get_rulelist_from_code(V_SAVE_RULES,
+ 						ps_global->rule_list);
+ 	RULE_S *prule = get_rule(list, n);
+ 	if (condition_contains_token(prule->condition, "_FLAG_")
+ 	     || (mc->valid && mc->seen && !mc->deleted) 
+ 	     || (!mc->valid && mc->searched))
+ 	     save_folder = cpystr(folder_to_save);
+ 	  else
+ 	     save_folder = NULL;
+     }
+     else
+        if (!mc || (mc->seen && !mc->deleted))
+ 	  save_folder = cpystr(dstfldr);
+     mn_give(&msgmap);
+     rule_curpos = 0L;
+     return save_folder;
+ }
  
  
  /*----------------------------------------------------------------------
***************
*** 10235,10241 ****
         && ((context_isambig(folder)
  	    && folder_is_nick(folder, FOLDERS(context), 0))
  	   || folder_index(folder, context, FI_FOLDER) > 0)
!        && (seen_undel = count_flagged(stream, F_SEEN | F_UNDEL))){
  
  	for(; f && *archive; archive++){
  	    char *p;
--- 10482,10490 ----
         && ((context_isambig(folder)
  	    && folder_is_nick(folder, FOLDERS(context), 0))
  	   || folder_index(folder, context, FI_FOLDER) > 0)
!        && ((seen_undel = count_flagged(stream, F_SEEN | F_UNDEL))
! 	   || (F_ON(F_AUTO_READ_MSGS,ps_global) &&
! 	       F_ON(F_AUTO_READ_MSGS_RULES, ps_global)))){
  
  	for(; f && *archive; archive++){
  	    char *p;
diff -rc pine4.64/pine/mailindx.c pine4.64.rules/pine/mailindx.c
*** pine4.64/pine/mailindx.c	Tue May  3 15:00:53 2005
--- pine4.64.rules/pine/mailindx.c	Sun Oct 15 08:02:22 2006
***************
*** 321,326 ****
--- 321,329 ----
  /*
   * Internal prototypes
   */
+ SortOrder	translate PROTO((char *, int));
+ char	        *find_value PROTO((char *, INDEXDATA_S *, int));
+ void	        setup_threading_display_style PROTO((void));
  void            index_index_screen PROTO((struct pine *));
  void            thread_index_screen PROTO((struct pine *));
  void            setup_for_index_index_screen PROTO((void));
***************
*** 595,600 ****
--- 598,605 ----
      state->prev_screen = mail_index_screen;
      state->next_screen = SCREEN_FUN_NULL;
  
+     setup_threading_display_style();
+ 
      if(THRD_AUTO_VIEW() && sp_viewing_a_thread(state->mail_stream)
         && state->view_skipped_index)
        unview_thread(state, state->mail_stream, state->msgmap);
***************
*** 3034,3076 ****
  static INDEX_PARSE_T itokens[] = {
      {"STATUS",		iStatus,	FOR_INDEX},
      {"MSGNO",		iMessNo,	FOR_INDEX},
!     {"DATE",		iDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"FROMORTO",	iFromTo,	FOR_INDEX},
      {"FROMORTONOTNEWS",	iFromToNotNews,	FOR_INDEX},
      {"SIZE",		iSize,		FOR_INDEX},
      {"SIZECOMMA",	iSizeComma,	FOR_INDEX},
      {"SIZENARROW",	iSizeNarrow,	FOR_INDEX},
      {"KSIZE",		iKSize,		FOR_INDEX},
!     {"SUBJECT",		iSubject,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"FULLSTATUS",	iFStatus,	FOR_INDEX},
      {"IMAPSTATUS",	iIStatus,	FOR_INDEX},
      {"SUBJKEY",		iSubjKey,	FOR_INDEX},
      {"SUBJKEYINIT",	iSubjKeyInit,	FOR_INDEX},
!     {"KEY",		iKey,		FOR_INDEX},
!     {"KEYINIT",		iKeyInit,	FOR_INDEX},
      {"DESCRIPSIZE",	iDescripSize,	FOR_INDEX},
      {"ATT",		iAtt,		FOR_INDEX},
      {"SCORE",		iScore,		FOR_INDEX},
!     {"LONGDATE",	iLDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SHORTDATE1",	iS1Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SHORTDATE2",	iS2Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SHORTDATE3",	iS3Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SHORTDATE4",	iS4Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DATEISO",		iDateIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SHORTDATEISO",	iDateIsoS,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATE",	iSDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTTIME",	iSTime,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIME",	iSDateTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"TIME24",		iTime24,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"TIME12",		iTime12,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"TIMEZONE",	iTimezone,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"MONTHABBREV",	iMonAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAYOFWEEKABBREV",	iDayOfWeekAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAYOFWEEK",	iDayOfWeek,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"FROM",		iFrom,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"TO",		iTo,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SENDER",		iSender,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"CC",		iCc,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"RECIPS",		iRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"NEWS",		iNews,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"TOANDNEWS",	iToAndNews,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
--- 3039,3084 ----
  static INDEX_PARSE_T itokens[] = {
      {"STATUS",		iStatus,	FOR_INDEX},
      {"MSGNO",		iMessNo,	FOR_INDEX},
!     {"DATE",		iDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
      {"FROMORTO",	iFromTo,	FOR_INDEX},
      {"FROMORTONOTNEWS",	iFromToNotNews,	FOR_INDEX},
      {"SIZE",		iSize,		FOR_INDEX},
      {"SIZECOMMA",	iSizeComma,	FOR_INDEX},
      {"SIZENARROW",	iSizeNarrow,	FOR_INDEX},
      {"KSIZE",		iKSize,		FOR_INDEX},
!     {"SUBJECT",		iSubject,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_TRIM},
      {"FULLSTATUS",	iFStatus,	FOR_INDEX},
      {"IMAPSTATUS",	iIStatus,	FOR_INDEX},
      {"SUBJKEY",		iSubjKey,	FOR_INDEX},
      {"SUBJKEYINIT",	iSubjKeyInit,	FOR_INDEX},
!     {"KEY",		iKey,		FOR_INDEX|FOR_RULE|FOR_SAVE|FOR_COMPOSE},
!     {"KEYINIT",		iKeyInit,	FOR_INDEX|FOR_RULE|FOR_SAVE|FOR_COMPOSE},
      {"DESCRIPSIZE",	iDescripSize,	FOR_INDEX},
      {"ATT",		iAtt,		FOR_INDEX},
      {"SCORE",		iScore,		FOR_INDEX},
!     {"LONGDATE",	iLDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SHORTDATE1",	iS1Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SHORTDATE2",	iS2Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SHORTDATE3",	iS3Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SHORTDATE4",	iS4Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DATEISO",		iDateIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SHORTDATEISO",	iDateIsoS,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATE",	iSDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTTIME",	iSTime,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIME",	iSDateTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"TIME24",		iTime24,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"TIME12",		iTime12,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"TIMEZONE",	iTimezone,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"MONTHABBREV",	iMonAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DAYOFWEEKABBREV",	iDayOfWeekAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DAYOFWEEK",	iDayOfWeek,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"FROM",		iFrom,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE|FOR_COMPOSE},
!     {"TO",		iTo,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE|FOR_COMPOSE},
!     {"SENDER",		iSender,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE},
!     {"CC",		iCc,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE},
!     {"ADDRESSTO",	iAddressTo,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE},
!     {"ADDRESSCC",	iAddressCc,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE},
!     {"ADDRESSRECIPS",	iAddressRecip,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_RULE},
      {"RECIPS",		iRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"NEWS",		iNews,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"TOANDNEWS",	iToAndNews,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
***************
*** 3079,3124 ****
      {"NEWSANDRECIPS",	iNewsAndRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"MSGID",		iMsgID,		FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"CURNEWS",		iCurNews,	FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAYDATE",		iRDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAY",		iDay,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAYORDINAL",	iDayOrdinal,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAY2DIGIT",	iDay2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"MONTHLONG",	iMonLong,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"MONTH",		iMon,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"MONTH2DIGIT",	iMon2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"YEAR",		iYear,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"YEAR2DIGIT",	iYear2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"ADDRESS",		iAddress,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"MAILBOX",		iMailbox,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"ROLENICK",       	iRoleNick,	FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"INIT",		iInit,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"CURDATE",		iCurDate,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURDATEISO",	iCurDateIso,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURDATEISOS",	iCurDateIsoS,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURTIME24",	iCurTime24,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURTIME12",	iCurTime12,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURDAY",		iCurDay,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURDAY2DIGIT",	iCurDay2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURDAYOFWEEK",	iCurDayOfWeek,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
      {"CURDAYOFWEEKABBREV", iCurDayOfWeekAbb,
! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURMONTH",	iCurMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURMONTH2DIGIT",	iCurMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURMONTHLONG",	iCurMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURMONTHABBREV",	iCurMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURYEAR",		iCurYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURYEAR2DIGIT",	iCurYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTMONTH",	iLstMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTMONTH2DIGIT",	iLstMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTMONTHLONG",	iLstMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTMONTHABBREV",	iLstMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTMONTHYEAR",	iLstMonYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
      {"LASTMONTHYEAR2DIGIT", iLstMonYear2Digit,
! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTYEAR",	iLstYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTYEAR2DIGIT",	iLstYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
      {"ARROW",		iArrow,		FOR_INDEX},
      {"CURSORPOS",	iCursorPos,	FOR_TEMPLATE},
      {NULL,		iNothing,	FOR_NOTHING}
  };
  
--- 3087,3144 ----
      {"NEWSANDRECIPS",	iNewsAndRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"MSGID",		iMsgID,		FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"CURNEWS",		iCurNews,	FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAYDATE",		iRDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DAY",		iDay,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DAYORDINAL",	iDayOrdinal,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DAY2DIGIT",	iDay2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"MONTHLONG",	iMonLong,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"MONTH",		iMon,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"MONTH2DIGIT",	iMon2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"YEAR",		iYear,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"YEAR2DIGIT",	iYear2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"ADDRESS",		iAddress,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE},
      {"MAILBOX",		iMailbox,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"ROLENICK",       	iRoleNick,	FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"INIT",		iInit,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"CURDATE",		iCurDate,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURDATEISO",	iCurDateIso,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURDATEISOS",	iCurDateIsoS,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURTIME24",	iCurTime24,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURTIME12",	iCurTime12,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURDAY",		iCurDay,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURDAY2DIGIT",	iCurDay2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURDAYOFWEEK",	iCurDayOfWeek,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
      {"CURDAYOFWEEKABBREV", iCurDayOfWeekAbb,
! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURMONTH",	iCurMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURMONTH2DIGIT",	iCurMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURMONTHLONG",	iCurMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURMONTHABBREV",	iCurMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURYEAR",		iCurYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"CURYEAR2DIGIT",	iCurYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"LASTMONTH",	iLstMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"LASTMONTH2DIGIT",	iLstMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"LASTMONTHLONG",	iLstMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"LASTMONTHABBREV",	iLstMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"LASTMONTHYEAR",	iLstMonYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
      {"LASTMONTHYEAR2DIGIT", iLstMonYear2Digit,
! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"LASTYEAR",	iLstYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
!     {"LASTYEAR2DIGIT",	iLstYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_FILT},
      {"ARROW",		iArrow,		FOR_INDEX},
      {"CURSORPOS",	iCursorPos,	FOR_TEMPLATE},
+     {"NICK",		iNick,		FOR_RULE|FOR_SAVE},
+     {"FOLDER",		iFolder,	FOR_RULE|FOR_SAVE|FOR_FOLDER},
+     {"ROLE",		iRole,		FOR_RULE|FOR_RESUB|FOR_TRIM|FOR_TEMPLATE},
+     {"PROCID",		iProcid,	FOR_RULE|FOR_RESUB|FOR_FLAG|FOR_COMPOSE|FOR_TRIM|FOR_TEMPLATE},
+     {"PKEY",		iPkey,		FOR_RULE|FOR_KEY},
+     {"SCREEN",		iScreen,	FOR_RULE|FOR_KEY},
+     {"FLAG",		iFlag,		FOR_RULE|FOR_SAVE|FOR_FLAG},
+     {"COLLECTION",	iCollection,	FOR_RULE|FOR_SAVE|FOR_COMPOSE|FOR_FOLDER},
+     {"BCC",		iBcc,		FOR_COMPOSE|FOR_RULE},
+     {"LCC",		iLcc,		FOR_COMPOSE|FOR_RULE},
+     {"FORWARDFROM",	iFfrom,		FOR_COMPOSE|FOR_RULE},
+     {"FORWARDADDRESS",	iFadd,		FOR_COMPOSE|FOR_RULE},
      {NULL,		iNothing,	FOR_NOTHING}
  };
  
***************
*** 3814,3819 ****
--- 3834,3871 ----
  }
  
  
+ /*---------------------------------
+ 
+ -----------*/
+ 
+ char *
+ find_value(token, idata, nfcn)
+ char *token;
+ INDEXDATA_S *idata;
+ int nfcn;
+ {int n = 0, i, rule_context;
+  char  *rule_result = NULL, **list;
+  RULELIST *rule;
+  RULE_S *prule;
+ 	 
+  if(rule = get_rulelist_from_code(V_REPLACE_RULES, ps_global->rule_list)){
+     list = functions_for_token(token);
+     while(rule_result == NULL && (prule = get_rule(rule,n++))){
+ 	rule_context = 0;
+ 	if (prule->action->token && !strcmp(prule->action->token, token)){
+ 	   for (i = 0; i < nfcn; i++)
+ 	      if(list[i+1] && !strcmp(prule->action->function, list[i+1]))
+ 	         rule_context |= context_for_function(list[i+1]);
+ 	   if (rule_context)
+ 	      rule_result = process_rule(prule, rule_context,
+ 			      mail_fetchenvelope(idata->stream, idata->rawno));
+ 	}
+     }
+  }
+  return rule_result;
+ }
+ 
+ 
  /*----------------------------------------------------------------------
        Create a string summarizing the message header for index on screen
  
***************
*** 4869,4874 ****
--- 4921,4939 ----
  		from_str(cdesc->ctype, idata, width, str);
  	        break;
  
+ 	      case iAddressTo:
+ 	      case iAddressCc:
+ 	      case iAddressRecip:
+ 		sprintf(str, "%-*.*s", width, width,
+ 		        detoken_src((cdesc->ctype == iAddressTo 
+ 				? "_ADDRESSTO_"
+ 				: (cdesc->ctype == iAddressCc
+ 				   ? "_ADRESSCC_"
+ 				   : "_ADRESSRECIPS_")), FOR_INDEX, 
+ 			pine_mail_fetchenvelope(idata->stream, idata->rawno),
+ 			NULL, NULL, NULL));
+ 		break;
+ 
  	      case iTo:
  		if(((field = ((addr = fetch_to(idata))
  			      ? "To"
***************
*** 7031,7041 ****
      unsigned long  rawno;
      unsigned char  buf[MAILTMPLEN];
      OFFCOLOR_S     myoffs[OFFS];
!     int            mynoff = 0;
  
      memset(str, 0, (width+1) * sizeof(*str));
      origstr = str;
!     origsubj = fetch_subject(idata);
      if(!origsubj)
        origsubj = "";
  
--- 7096,7114 ----
      unsigned long  rawno;
      unsigned char  buf[MAILTMPLEN];
      OFFCOLOR_S     myoffs[OFFS];
!     int            mynoff = 0, we_clear = 0;
!     char	  *rule_result;
  
      memset(str, 0, (width+1) * sizeof(*str));
      origstr = str;
!     rule_result = find_value("_SUBJECT_", idata, 3);
!     if (rule_result){
!        we_clear++;
!        origsubj = cpystr(rule_result);
!        fs_give((void **)&rule_result);
!     }
!     else
!       origsubj = fetch_subject(idata);
      if(!origsubj)
        origsubj = "";
  
***************
*** 7316,7321 ****
--- 7389,7396 ----
  
      if(free_subj)
        fs_give((void **) &free_subj);
+     if (we_clear && origsubj)
+       fs_give((void **)&origsubj);
  
      /* adjust offsets for indents and subject truncation */
      if(offs && noff && *noff < OFFS && mynoff && pico_usingcolor()){
***************
*** 7635,7650 ****
  				 ? "To"
  				 : (addr = fetch_cc(idata))
  				 ? "Cc"
! 				 : NULL))
! 		       && set_index_addr(idata, field, addr, "To: ",
! 					 width, fptr))
! 		      break;
! 
  		    if(ctype == iFromTo &&
  		       (newsgroups = fetch_newsgroups(idata)) &&
  		       *newsgroups){
! 			sprintf(fptr, "To: %-*.*s", width-4, width-4,
! 				newsgroups);
  			break;
  		    }
  
--- 7710,7739 ----
  				 ? "To"
  				 : (addr = fetch_cc(idata))
  				 ? "Cc"
! 				 : NULL))){
! 			 char *rule_result;
! 			 rule_result = find_value("_FROM_", idata, 1);
!                          if (!rule_result)
!                             set_index_addr(idata, field, addr, "To: ",
!                                       width, str);
!                          else{
!                             sprintf(str, "%-*.*s", width, width, rule_result);
!                             fs_give((void **)&rule_result);
!                          }
!                          break;
! 		    }
  		    if(ctype == iFromTo &&
  		       (newsgroups = fetch_newsgroups(idata)) &&
  		       *newsgroups){
!                            char *rule_result;
! 			   rule_result = find_value("_FROM_", idata, 1);
!                            if (!rule_result)
!                               sprintf(str, "To: %-*.*s", width-4, width-4,
!                                   newsgroups);
!                            else{
!                                sprintf(str, "%-*.*s", width, width, rule_result);
!                               fs_give((void **)&rule_result);
!                            }
  			break;
  		    }
  
***************
*** 7657,7664 ****
  	      break;
  
  	  case iFrom:
! 	    set_index_addr(idata, "From", fetch_from(idata),
! 			   NULL, width, fptr);
  	    break;
  
  	  case iAddress:
--- 7746,7762 ----
  	      break;
  
  	  case iFrom:
!               { char *rule_result;
! 		rule_result = find_value("_FROM_", idata, 3);
!                 if (!rule_result)
!                    set_index_addr(idata, "From", fetch_from(idata),
!                              NULL, width, str);
!                 else{  
!                   sprintf(str, "%-*.*s", width, width, rule_result);
!                   fs_give((void **)&rule_result);
!                 }   
!               }
! 
  	    break;
  
  	  case iAddress:
***************
*** 8054,8059 ****
--- 8152,8194 ----
  	    : ((mdiff = *mess_a - *mess_b) ? ((mdiff > 0) ? 1 : -1) : 0));
  }
  
+ SortOrder  translate(order, is_rev)
+ char *order;
+ int   is_rev;
+ {
+    int rev = 0;
+      if (!strncmp(order,"tHread", 6) 
+ 		|| (rev = !strncmp(order,"Reverse tHread", 14)))
+ 	return is_rev || rev ? SortThread : EndofList;
+      if (!strncmp(order,"OrderedSubj", 11)
+ 		|| (rev = !strncmp(order,"Reverse OrderedSubj", 19)))
+ 	return is_rev || rev  ? SortSubject2 : EndofList;
+      if (!strncmp(order,"Subject", 7)
+ 		|| (rev = !strncmp(order,"Reverse SortSubject", 15)))
+ 	return is_rev || rev  ?  SortSubject : EndofList;
+      if (!strncmp(order,"Arrival", 7)
+ 		|| (rev = !strncmp(order,"Reverse Arrival", 15)))
+ 	return is_rev || rev  ?  SortArrival : EndofList;
+      if (!strncmp(order,"From", 4)
+ 		|| (rev = !strncmp(order,"Reverse From", 12)))
+ 	return is_rev || rev  ?  SortFrom : EndofList;
+      if (!strncmp(order,"To", 2)
+ 		|| (rev = !strncmp(order,"Reverse To", 10)))
+ 	return is_rev || rev  ?  SortTo : EndofList;
+      if (!strncmp(order,"Cc", 2)
+ 		|| (rev = !strncmp(order,"Reverse Cc", 10)))
+ 	return is_rev || rev  ?  SortCc : EndofList;
+      if (!strncmp(order,"Date", 4)
+ 		|| (rev = !strncmp(order,"Reverse Date", 12)))
+ 	return is_rev || rev  ?  SortDate : EndofList;
+      if (!strncmp(order,"siZe", 4)
+ 		|| (rev = !strncmp(order,"Reverse siZe", 12)))
+ 	return is_rev || rev  ?  SortSize : EndofList;
+      if (!strncmp(order,"scorE", 5)
+ 		|| (rev = !strncmp(order,"Reverse scorE", 13)))
+ 	return is_rev || rev  ?  SortScore : EndofList;
+    return EndofList;
+ }
  
  /*----------------------------------------------------------------------
      Sort the current folder into the order set in the msgmap
***************
*** 11714,11716 ****
--- 11849,11874 ----
  	}
      }
  }
+ 
+ void
+ setup_threading_display_style()
+ {
+   RULE_RESULT *rule;
+   NAMEVAL_S *v;
+   int i;
+ 
+   rule = get_result_rule(V_THREAD_DISP_STYLE_RULES, FOR_THREAD, NULL);
+   if (rule || ps_global->VAR_THREAD_DISP_STYLE){
+      for(i = 0; v = thread_disp_styles(i); i++)
+         if(!strucmp(rule ? rule->result : ps_global->VAR_THREAD_DISP_STYLE, 
+ 		    rule ? (v ? v->name : "" ) : S_OR_L(v))){
+               ps_global->thread_disp_style = v->value;
+               break;
+         }
+      if (rule){
+ 	if (rule->result)
+ 	   fs_give((void **)&rule->result);
+ 	fs_give((void **)&rule);
+      }
+   }
+ }
diff -rc pine4.64/pine/osdep/termin.gen pine4.64.rules/pine/osdep/termin.gen
*** pine4.64/pine/osdep/termin.gen	Wed Dec  1 10:56:45 2004
--- pine4.64.rules/pine/osdep/termin.gen	Tue Oct 17 07:36:28 2006
***************
*** 75,80 ****
--- 75,111 ----
      }
  
      ch = read_char(tm);
+     if(!ps_global->initial_cmds){
+ 	RULE_RESULT *rule;
+ 	char **list = NULL, *error = NULL;
+ 	int    commas = 0, k;   /* From args.c */
+ 
+ 	ps_global->pressed_key = cpystr(pretty_command(ch));
+ 	rule = (RULE_RESULT *)get_result_rule(V_KEY_RULES, FOR_KEY, NULL);
+ 	if(ps_global->pressed_key)
+ 	  fs_give((void **)&ps_global->pressed_key);
+ 	if (rule){
+ 	   for(k = 0; rule->result[k]; k++)
+ 	      if(rule->result[k] == ',') commas++;
+ 	   list = parse_list(rule->result, commas+1, 0, &error);
+ 	   if(error)
+ 	      sprintf(tmp_20k_buf, "Error in parsing command list: %s, %s",
+ 			rule->result, error);
+ 	   if (rule->result)
+ 	     fs_give((void **)&rule->result);
+ 	   fs_give((void **)&rule);
+ 	   if(error){
+ 	      q_status_message(SM_ORDER | SM_DING, 0, 2, tmp_20k_buf);
+ 	      return (NO_OP_COMMAND);
+ 	   }
+ 	   process_init_cmds(ps_global, list);
+ 	   ch = read_char(tm);
+ 	   ps_global->in_init_seq = 1;	/* no output please */
+ 	   for(k = 0; k < commas; k++)
+ 	      if(list[k]) fs_give((void **)&list[k]);
+ 	   if (list) fs_give((void **)list);
+ 	}
+     }
      dprint(9, (debugfile, "Read command returning: %d %s\n", ch,
                pretty_command(ch)));
      if(ch != NO_OP_COMMAND && ch != NO_OP_IDLE && ch != KEY_RESIZE)
***************
*** 1033,1038 ****
--- 1064,1070 ----
  	if(!*ps_global->initial_cmds && ps_global->free_initial_cmds){
  	    fs_give((void **)&(ps_global->free_initial_cmds));
  	    ps_global->initial_cmds = 0;
+ 	    firsttime = (char) 1;
  	}
  
  	return(1);
diff -rc pine4.64/pine/osdep/termout.unx pine4.64.rules/pine/osdep/termout.unx
*** pine4.64/pine/osdep/termout.unx	Tue Nov 30 09:54:05 2004
--- pine4.64.rules/pine/osdep/termout.unx	Mon Oct 16 12:35:20 2006
***************
*** 321,327 ****
      _line = 0;	/* clear leaves us at top... */
      _col  = 0;
  
!     if(ps_global->in_init_seq)
        return;
  
      mark_status_unknown();
--- 321,327 ----
      _line = 0;	/* clear leaves us at top... */
      _col  = 0;
  
!     if(ps_global->in_init_seq && !ps_global->password)
        return;
  
      mark_status_unknown();
***************
*** 382,388 ****
  
      /* we don't want to change "rows" or we'll mangle scrolling... */
  
!     if(ps_global->in_init_seq)
        return;
  
      if (col < 0)
--- 382,388 ----
  
      /* we don't want to change "rows" or we'll mangle scrolling... */
  
!     if(ps_global->in_init_seq && !ps_global->password)
        return;
  
      if (col < 0)
***************
*** 746,752 ****
  {
      static   int esc_len = 0;
  
!     if(ps_global->in_init_seq				/* silent */
         || (F_ON(F_BLANK_KEYMENU, ps_global)		/* or bottom, */
  	   && !esc_len					/* right cell */
  	   && _line + 1 == ps_global->ttyo->screen_rows
--- 746,752 ----
  {
      static   int esc_len = 0;
  
!     if((ps_global->in_init_seq	&& !ps_global->password)/* silent */
         || (F_ON(F_BLANK_KEYMENU, ps_global)		/* or bottom, */
  	   && !esc_len					/* right cell */
  	   && _line + 1 == ps_global->ttyo->screen_rows
diff -rc pine4.64/pine/other.c pine4.64.rules/pine/other.c
*** pine4.64/pine/other.c	Mon Sep 12 15:04:25 2005
--- pine4.64.rules/pine/other.c	Mon Oct 16 10:55:21 2006
***************
*** 7482,7487 ****
--- 7482,7515 ----
  	return(h_config_ab_sort_rule);
        case V_FLD_SORT_RULE :
  	return(h_config_fld_sort_rule);
+       case V_THREAD_DISP_STYLE_RULES:
+ 	return(h_config_thread_display_style_rule);
+       case V_THREAD_INDEX_STYLE_RULES:
+ 	return(h_config_thread_index_style_rule);
+       case V_COMPOSE_RULES:
+ 	return(h_config_compose_rules);
+       case V_FORWARD_RULES:
+ 	return(h_config_forward_rules);
+       case V_INDEX_RULES:
+ 	return(h_config_index_rules);
+       case V_KEY_RULES:
+ 	return(h_config_key_macro_rules);
+       case V_REPLACE_RULES:
+ 	return(h_config_replace_rules);
+       case V_REPLY_INDENT_RULES:
+ 	return(h_config_reply_indent_rules);
+       case V_REPLY_LEADIN_RULES:
+ 	return(h_config_reply_leadin_rules);
+       case V_RESUB_RULES:
+ 	return(h_config_resub_rules);
+       case V_SAVE_RULES:
+ 	return(h_config_save_rules);
+       case V_SMTP_RULES:
+ 	return(h_config_smtp_rules);
+       case V_SORT_RULES:
+ 	return(h_config_sort_rules);
+       case V_STARTUP_RULES:
+ 	return(h_config_startup_rules);
        case V_CHAR_SET :
  	return(h_config_char_set);
        case V_EDITOR :
***************
*** 8842,8848 ****
  	 * Now go and set the current_val based on user_val changes
  	 * above.  Turn off command line settings...
  	 */
! 	set_current_val((*cl)->var, TRUE, FALSE);
  	fix_side_effects(ps, (*cl)->var, 0);
  
  	/*
--- 8870,8878 ----
  	 * Now go and set the current_val based on user_val changes
  	 * above.  Turn off command line settings...
  	 */
! 	set_current_val((*cl)->var, 
! 	    (strcmp((*cl)->var->name,"key-definition-rules") ? TRUE : FALSE), 
! 	    FALSE);
  	fix_side_effects(ps, (*cl)->var, 0);
  
  	/*
***************
*** 12695,12700 ****
--- 12725,12752 ----
  	    var == &ps->vars[V_ABOOK_FORMATS]){
  	addrbook_reset();
      }
+     else if(var == &ps->vars[V_COMPOSE_RULES] || 
+ 	    var == &ps->vars[V_FORWARD_RULES] ||
+ 	    var == &ps->vars[V_INDEX_RULES] ||
+ 	    var == &ps->vars[V_KEY_RULES] ||
+ 	    var == &ps->vars[V_REPLACE_RULES] ||
+ 	    var == &ps->vars[V_REPLY_INDENT_RULES] ||
+ 	    var == &ps->vars[V_REPLY_LEADIN_RULES] ||
+ 	    var == &ps->vars[V_RESUB_RULES] ||
+ 	    var == &ps->vars[V_SAVE_RULES] ||
+ 	    var == &ps->vars[V_SMTP_RULES] ||
+ 	    var == &ps->vars[V_SORT_RULES] ||
+ 	    var == &ps->vars[V_STARTUP_RULES] ||
+ 	    var == &ps->vars[V_THREAD_DISP_STYLE_RULES] ||
+ 	    var == &ps->vars[V_THREAD_INDEX_STYLE_RULES]){
+ 	if(ps_global->rule_list)
+ 	   free_parsed_rule_list(&ps_global->rule_list);
+         create_rule_list();
+ 	if(var == &ps->vars[V_INDEX_RULES]){
+ 	   reset_index_format();
+ 	   clear_iindex_cache();
+ 	}
+     }
      else if(var == &ps->vars[V_INDEX_FORMAT]){
  	reset_index_format();
  	clear_iindex_cache();
***************
*** 21350,21355 ****
--- 21402,21412 ----
  	    if(apval)
  	      *apval = (role && role->nick) ? cpystr(role->nick) : NULL;
  
+ 	    if (ps_global->role)
+                 fs_give((void **)&ps_global->role);  
+ 	    if (role && role->nick)
+ 		ps_global->role = cpystr(role->nick);
+ 
  	    if((*cl)->value)
  	      fs_give((void **)&((*cl)->value));
  
***************
*** 24702,24704 ****
--- 24759,24763 ----
      return(TRUE);
  }
  #endif	/* _WINDOWS */
+ 
+ #include "rules.c"
diff -rc pine4.64/pine/pine.c pine4.64.rules/pine/pine.c
*** pine4.64/pine/pine.c	Mon Sep 12 15:04:25 2005
--- pine4.64.rules/pine/pine.c	Sat Oct 14 08:55:29 2006
***************
*** 3226,3231 ****
--- 3226,3232 ----
      extern KBESC_T *kbesc;
  
      dprint(2, (debugfile, "goodnight_gracey:\n"));    
+     sprintf(pine_state->cur_folder, pine_state->inbox_name);
  
      /* We want to do this here before we close up the streams */
      trim_remote_adrbks();
***************
*** 3426,3431 ****
--- 3427,3435 ----
  
  	fs_give((void **)&ps_global->atmts);
      }
+ 
+     if(ps_global->rule_list)
+        free_parsed_rule_list(&ps_global->rule_list);
      
      dprint(7, (debugfile, "goodnight_gracey: free_vars\n"));    
      free_vars(pine_state);
diff -rc pine4.64/pine/pine.h pine4.64.rules/pine/pine.h
*** pine4.64/pine/pine.h	Thu Sep 15 17:39:42 2005
--- pine4.64.rules/pine/pine.h	Mon Oct 16 12:22:13 2006
***************
*** 651,656 ****
--- 651,670 ----
  		, V_THREAD_MORE_CHAR
  		, V_THREAD_EXP_CHAR
  		, V_THREAD_LASTREPLY_CHAR
+ 		, V_THREAD_DISP_STYLE_RULES
+ 		, V_THREAD_INDEX_STYLE_RULES
+ 		, V_COMPOSE_RULES
+ 		, V_FORWARD_RULES
+ 		, V_INDEX_RULES
+ 		, V_KEY_RULES
+ 		, V_REPLACE_RULES
+ 		, V_REPLY_INDENT_RULES
+ 		, V_REPLY_LEADIN_RULES
+ 		, V_RESUB_RULES
+ 		, V_SAVE_RULES
+ 		, V_SMTP_RULES
+ 		, V_SORT_RULES
+ 		, V_STARTUP_RULES
  		, V_CHAR_SET
  		, V_EDITOR
  		, V_SPELLER
***************
*** 899,904 ****
--- 913,958 ----
  #define GLO_AB_SORT_RULE	     vars[V_AB_SORT_RULE].global_val.p
  #define VAR_FLD_SORT_RULE	     vars[V_FLD_SORT_RULE].current_val.p
  #define GLO_FLD_SORT_RULE	     vars[V_FLD_SORT_RULE].global_val.p
+ #define VAR_COMPOSE_RULES	     vars[V_COMPOSE_RULES].current_val.l
+ #define GLO_COMPOSE_RULES	     vars[V_COMPOSE_RULES].global_val.l
+ #define USR_COMPOSE_RULES	     vars[V_COMPOSE_RULES].user_val.l
+ #define VAR_FORWARD_RULES	     vars[V_FORWARD_RULES].current_val.l
+ #define GLO_FORWARD_RULES	     vars[V_FORWARD_RULES].global_val.l
+ #define USR_FORWARD_RULES	     vars[V_FORWARD_RULES].user_val.l
+ #define VAR_INDEX_RULES		     vars[V_INDEX_RULES].current_val.l
+ #define GLO_INDEX_RULES		     vars[V_INDEX_RULES].global_val.l
+ #define USR_INDEX_RULES		     vars[V_INDEX_RULES].user_val.l
+ #define VAR_KEY_RULES		     vars[V_KEY_RULES].current_val.l
+ #define GLO_KEY_RULES		     vars[V_KEY_RULES].global_val.l
+ #define USR_KEY_RULES		     vars[V_KEY_RULES].user_val.l
+ #define VAR_REPLACE_RULES	     vars[V_REPLACE_RULES].current_val.l
+ #define GLO_REPLACE_RULES	     vars[V_REPLACE_RULES].global_val.l
+ #define USR_REPLACE_RULES	     vars[V_REPLACE_RULES].user_val.l
+ #define VAR_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].current_val.l
+ #define GLO_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].global_val.l
+ #define USR_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].user_val.l
+ #define VAR_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].current_val.l
+ #define GLO_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].global_val.l
+ #define USR_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].user_val.l
+ #define VAR_RESUB_RULES		     vars[V_RESUB_RULES].current_val.l
+ #define GLO_RESUB_RULES		     vars[V_RESUB_RULES].global_val.l
+ #define USR_RESUB_RULES		     vars[V_RESUB_RULES].user_val.l
+ #define VAR_THREAD_DISP_STYLE_RULES  vars[V_THREAD_DISP_STYLE_RULES].current_val.l
+ #define GLO_THREAD_DISP_STYLE_RULES  vars[V_THREAD_DISP_STYLE_RULES].global_val.l
+ #define VAR_THREAD_INDEX_STYLE_RULES vars[V_THREAD_INDEX_STYLE_RULES].current_val.l
+ #define GLO_THREAD_INDEX_STYLE_RULES vars[V_THREAD_INDEX_STYLE_RULES].global_val.l
+ #define VAR_SAVE_RULES		     vars[V_SAVE_RULES].current_val.l
+ #define GLO_SAVE_RULES		     vars[V_SAVE_RULES].global_val.l
+ #define USR_SAVE_RULES		     vars[V_SAVE_RULES].user_val.l
+ #define VAR_SMTP_RULES		     vars[V_SMTP_RULES].current_val.l
+ #define GLO_SMTP_RULES		     vars[V_SMTP_RULES].global_val.l
+ #define USR_SMTP_RULES		     vars[V_SMTP_RULES].user_val.l
+ #define VAR_SORT_RULES		     vars[V_SORT_RULES].current_val.l
+ #define GLO_SORT_RULES		     vars[V_SORT_RULES].global_val.l
+ #define USR_SORT_RULES		     vars[V_SORT_RULES].user_val.l
+ #define VAR_STARTUP_RULES	     vars[V_STARTUP_RULES].current_val.l
+ #define GLO_STARTUP_RULES	     vars[V_STARTUP_RULES].global_val.l
+ #define USR_STARTUP_RULES	     vars[V_STARTUP_RULES].user_val.l
  #define VAR_CHAR_SET		     vars[V_CHAR_SET].current_val.p
  #define GLO_CHAR_SET		     vars[V_CHAR_SET].global_val.p
  #define VAR_EDITOR		     vars[V_EDITOR].current_val.l
***************
*** 1151,1156 ****
--- 1205,1211 ----
  	F_FULL_AUTO_EXPUNGE,
  	F_EXPUNGE_MANUALLY,
  	F_AUTO_READ_MSGS,
+ 	F_AUTO_READ_MSGS_RULES,
  	F_AUTO_FCC_ONLY,
  	F_READ_IN_NEWSRC_ORDER,
  	F_SELECT_WO_CONFIRM,
***************
*** 2606,2611 ****
--- 2661,2669 ----
  	      iCurNews, iArrow,
  	      iMailbox, iAddress, iInit, iCursorPos,
  	      iDay2Digit, iMon2Digit, iYear2Digit,
+ 	      iFolder, iFlag, iCollection, iRole, iProcid, iScreen, iPkey,
+ 	      iNick, iAddressTo, iAddressCc, iAddressRecip, iBcc, iLcc, 
+ 	      iFfrom, iFadd,
  	      iSTime, iKSize,
  	      iRoleNick,
  	      iScore, iDayOfWeekAbb, iDayOfWeek,
***************
*** 2622,2634 ****
  } INDEX_PARSE_T;
  
  /* these are flags for the what_for field in INDEX_PARSE_T */
! #define FOR_NOTHING	0x00
! #define FOR_INDEX	0x01
! #define FOR_REPLY_INTRO	0x02
! #define FOR_TEMPLATE	0x04		/* or for signature */
! #define FOR_FILT	0x08
! #define DELIM_USCORE	0x10
! #define DELIM_PAREN	0x20
  
  #define DEFAULT_REPLY_INTRO "default"
  
--- 2680,2704 ----
  } INDEX_PARSE_T;
  
  /* these are flags for the what_for field in INDEX_PARSE_T */
! #define FOR_NOTHING	0x00000
! #define FOR_INDEX	0x00001
! #define FOR_REPLY_INTRO	0x00002
! #define FOR_TEMPLATE	0x00004  /* or for signature */
! #define FOR_FILT	0x00008
! #define DELIM_USCORE	0x00010
! #define DELIM_PAREN	0x00020
! #define FOR_SAVE	0x00040  /* for rules */
! #define FOR_FOLDER	0x00080  /* for rules */
! #define FOR_RULE	0x00100  /* for rules */
! #define FOR_TRIM	0x00200  /* for rules */
! #define FOR_RESUB	0x00400  /* for rules */
! #define FOR_REPLACE	0x00800  /* for rules */
! #define FOR_SORT	0x01000  /* for rules */
! #define FOR_FLAG	0x02000  /* for rules */
! #define FOR_COMPOSE	0x04000  /* for rules */
! #define FOR_THREAD	0x08000  /* for rules */
! #define FOR_STARTUP	0x10000  /* for rules */
! #define FOR_KEY		0x20000  /* for rules */
  
  #define DEFAULT_REPLY_INTRO "default"
  
***************
*** 3683,3690 ****
--- 3753,3812 ----
  #define	HEX_CHAR1(C)	HEX_ARRAY[((C) & 0xf0) >> 4]
  #define	HEX_CHAR2(C)	HEX_ARRAY[(C) & 0xf]
  
+ typedef struct rule {
+ 	char *result;   /* The result of the rule */
+ 	int number;     /* The number of the rule that succeded, -1 if not */   
+ } RULE_RESULT;
+ 
+ #define TOKEN_VALUE   struct tokenvalue_s
+ #define CONDITION_S   struct condition_s
+ #define RULEACTION_S  struct ruleaction_s
+ #define RULE_S        struct rule_s
+ #define RULELIST      struct rulelist_s
+ #define PRULELIST_S   struct parsedrulelist_s
+ 
+ TOKEN_VALUE {
+     char	*testxt;
+     TOKEN_VALUE *next;
+ };
+ 
+ typedef enum {Equal, Subset, Includes,
+ 	      NotEqual, NotSubset, NotIncludes,
+ 	      EndTypes} TestType;
+ 
+ CONDITION_S {
+    char		*tname;		/* tname ttype {value} */
+    TestType	ttype;		/* tname ttype {value} */
+    TOKEN_VALUE	*value;		/* value to check against */
+    CONDITION_S	*next;		/* next condition to test */
+ };
  
+ RULEACTION_S {
+    char *token;		/* token := function{value} or token = null  */
+    char *function;	/* token := function{value} or simply function{value}*/
+    TOKEN_VALUE  *value;	/* token := function{value} or simply function{value}*/
+    int   context;	/* context in which this rule can be used */
+    char* (*exec)();
+    unsigned int is_trim:1;
+    unsigned int is_rextrim:1;
+    unsigned int is_replace:1;
+ };
  
+ RULE_S {
+   CONDITION_S  *condition;
+   RULEACTION_S *action;
+ };
+ 
+ RULELIST {
+    RULE_S *prule;
+    RULELIST *next;
+ };
+ 
+ PRULELIST_S {
+    int varnum;	/* number associated to the variable */
+    RULELIST *rlist;
+    PRULELIST_S *next;
+ };
  
  /*------------------------------
    Structure to pass optionally_enter to tell it what keystrokes
***************
*** 4250,4255 ****
--- 4372,4381 ----
      MAILSTREAM  *mail_stream;		/* ptr to current folder stream */
      MSGNO_S	*msgmap;		/* ptr to current message map   */
  
+     char	*role;			/* role used when composing */
+     char	*procid;		/* procedure id when needed */
+     int		 exiting;
+ 
      unsigned     read_predicted:1;
  
      char         cur_folder[MAXPATH+1];
***************
*** 4447,4452 ****
--- 4573,4581 ----
      INIT_ERR_S  *init_errs;
  
      PRINT_S	*print;
+     PRULELIST_S *rule_list;
+     char	*pressed_key;
+     int		password:1;
  
      struct variable *vars;
  };
***************
*** 4742,4747 ****
--- 4871,4877 ----
  int	    set_mime_extension_by_type PROTO((char *, char *));
  
  /*---- mailcmd.c ----*/
+ MAILSTREAM *find_open_stream PROTO((void));
  int	    process_cmd PROTO((struct pine *, MAILSTREAM *, MSGNO_S *,
  			       int, CmdWhere, int *));
  int	    apply_command PROTO((struct pine *, MAILSTREAM *, MSGNO_S *, int,
***************
*** 4788,4793 ****
--- 4918,4924 ----
  char	   *get_uname PROTO((char *, char *, int));
  char	   *build_updown_cmd PROTO((char *, char *, char *, char*));
  int	    file_lister PROTO((char *, char *, int, char *, int, int, int));
+ unsigned long rules_cursor_pos PROTO((MAILSTREAM *));
  int	    display_folder_list PROTO((CONTEXT_S **, char *, int,
  				       int (*) PROTO((struct pine *,
  						      CONTEXT_S **,
***************
*** 5208,5213 ****
--- 5339,5387 ----
  void	    standard_picobuf_setup PROTO((PICO *));
  void	    standard_picobuf_teardown PROTO((PICO *));
  
+ /* -- rules.c -- */
+ RULE_RESULT *get_result_rule PROTO ((int, int, ENVELOPE *));
+ char	*get_rule_result PROTO((int , char *, int));
+ int      context_for_function PROTO((char *));
+ char  **functions_for_token PROTO((char *));
+ char	*test_rule	PROTO ((RULELIST *, int, ENVELOPE *, int *));
+ char	*process_rule	PROTO ((RULE_S *, int, ENVELOPE *));
+ int	test_condition	PROTO ((CONDITION_S *, int, ENVELOPE *));
+ int	test_in		PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ int	test_ni		PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ int	test_not_in	PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ int	test_not_ni	PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ int	test_eq		PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ int	test_not_eq	PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ int	isolate_condition PROTO ((char *, char **, int *));
+ int	condition_contains_token PROTO((CONDITION_S *, char *));
+ char	*trim		PROTO ((RULEACTION_S *, int, ENVELOPE *));
+ char	*rextrim	PROTO ((RULEACTION_S *, int, ENVELOPE *));
+ char	*raw_value	PROTO ((RULEACTION_S *, int, ENVELOPE *));
+ char	*extended_value	PROTO ((RULEACTION_S *, int, ENVELOPE *));
+ char	*expand		PROTO ((char *, char *));
+ char	*get_name_token PROTO ((char *));
+ char	*advance_to_char PROTO ((char *, char, int, int *));
+ void	free_token_value PROTO ((TOKEN_VALUE **));
+ void 	free_condition	PROTO ((CONDITION_S **));
+ void	free_ruleaction	PROTO ((RULEACTION_S **));
+ void	free_rule	PROTO ((RULE_S **));
+ void	free_rule_list	PROTO ((RULELIST **));
+ void	free_parsed_rule_list PROTO((PRULELIST_S **));
+ void	*alloc_mem	PROTO ((size_t));
+ void	add_rule	PROTO ((int, int));
+ void	create_rule_list PROTO ((void));
+ RULE_S	*parse_rule	PROTO ((char *, int));
+ RULE_S	*get_rule	PROTO ((RULELIST *, int));
+ RULELIST *get_rule_list PROTO ((char **, int, int));
+ RULELIST *get_rulelist_from_code PROTO((int, PRULELIST_S *));
+ TOKEN_VALUE *parse_group_data PROTO ((char *,int *));
+ TOKEN_VALUE *copy_parsed_value PROTO((TOKEN_VALUE *, int, ENVELOPE *));
+ CONDITION_S *fill_condition PROTO ((char *));
+ CONDITION_S *parse_condition PROTO ((char *, int *));
+ PRULELIST_S *add_prule	PROTO ((PRULELIST_S *, PRULELIST_S *));
+ RULEACTION_S *parse_action PROTO ((char *, int));
+ 
  /*-- screen.c --*/
  void	    draw_keymenu PROTO((struct key_menu *, bitmap_t, int, int,
  				int, OtherMenu));
***************
*** 5333,5338 ****
--- 5507,5513 ----
  void	    removing_leading_white_space PROTO((char *));
  void	    removing_leading_and_trailing_white_space PROTO((char *));
  int 	    removing_double_quotes PROTO((char *));
+ void	    removing_extra_stuff PROTO((char *));
  char	   *skip_white_space PROTO((char *));
  char	   *skip_to_white_space PROTO((char *));
  char	   *removing_quotes PROTO((char *));
diff -rc pine4.64/pine/pine.hlp pine4.64.rules/pine/pine.hlp
*** pine4.64/pine/pine.hlp	Wed Sep 28 10:56:29 2005
--- pine4.64.rules/pine/pine.hlp	Tue Oct 17 07:58:09 2006
***************
*** 3128,3133 ****
--- 3128,3134 ----
  <li><a href="h_config_alt_role_menu">FEATURE: Alternate-Role-Menu</a>
  <li><a href="h_config_force_low_speed">FEATURE: Assume-Slow-Link</a>
  <li><a href="h_config_auto_read_msgs">FEATURE: Auto-Move-Read-Msgs</a>
+ <li><a href="h_config_auto_read_msgs_rules">FEATURE: auto-move-read-msgs-using-rules</a>
  <li><a href="h_config_auto_open_unread">FEATURE: Auto-Open-Next-Unread</a>
  <li><a href="h_config_auto_unzoom">FEATURE: Auto-Unzoom-After-Apply</a>
  <li><a href="h_config_auto_zoom">FEATURE: Auto-Zoom-After-Select</a>
***************
*** 17396,17401 ****
--- 17397,17403 ----
  <A HREF="h_config_index_format">&quot;Index-Format&quot;</A> option,
  in the <A HREF="h_config_reply_intro">&quot;Reply-Leadin&quot;</A> option,
  in signature files,
+ in the <A HREF="h_config_reply_leadin_rules">&quot;new-rules&quot; option</A>,
  in template files used in
  <A HREF="h_rules_roles">&quot;roles&quot;</A>, and in the folder name
  that is the target of a Filter Rule.
***************
*** 17408,17414 ****
  <P>
  <P>
  
! <H1><EM>Tokens Available for all Cases (except Filter Rules)</EM></H1>
  
  <DL>
  <DT>SUBJECT</DT>
--- 17410,17416 ----
  <P>
  <P>
  
! <H1><EM>Tokens Available for all Cases (except Filter Rules or in some cases for new-rules)</EM></H1>
  
  <DL>
  <DT>SUBJECT</DT>
***************
*** 17430,17435 ****
--- 17432,17446 ----
  For example, &quot;mailbox@domain&quot;.
  </DD>
  
+ <DT>ADDRESSTO</DT>
+ <DD>
+ This is similar to the &quot;TO&quot; token, only it is always the
+ email address of all people listed in the TO: field of the messages. Addresses
+ are separated by a blank space. Example, &quot;mailbox@domain&quot; when
+ the e-mail message contains only one person in the To: field, or
+ &quot;peter@flintstones.com president@world.com&quot;.
+ </DD>
+ 
  <DT>MAILBOX</DT>
  <DD>
  This is the same as the &quot;ADDRESS&quot; except that the 
***************
*** 17477,17482 ****
--- 17488,17502 ----
  message's &quot;Cc:&quot; header field.
  </DD>
  
+ <DT>ADDRESSCC</DT>
+ <DD>
+ This is similar to the &quot;CC&quot; token, only it is always the
+ email address of all people listed in the Cc: field of the messages. Addresses
+ are separated by a blank space. Example: &quot;mailbox@domain&quot; when
+ the e-mail message contains only one person in the Cc: field, or
+ &quot;peter@flintstones.com president@world.com&quot;.
+ </DD>
+ 
  <DT>RECIPS</DT>
  <DD>
  This token represents the personal names (or email addresses if the names
***************
*** 17485,17490 ****
--- 17505,17518 ----
  the message's &quot;Cc:&quot; header field.
  </DD>
  
+ <DT>ADDRESSRECIPS</DT>
+ <DD>
+ This token represent the e-mail addresses of the people in the To: and
+ Cc: fields, exactly in that order separated by a space. It is almost obtained
+ by concatenating the ADDRESSTO and ADDRESSCC tokens.
+ </DD>
+ 
+ 
  <DT>NEWSANDRECIPS</DT>
  <DD>
  This token represents the newsgroups from the
***************
*** 18212,18217 ****
--- 18240,18317 ----
  </DL>
  
  <P>
+ <H1><EM>Tokens Available Only for New-Rules</EM></H1>
+ 
+ <DL>
+ <DT>FOLDER</DT>
+ <DD>
+ Name of the folder where the rule will be applied
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>COLLECTION</DT>
+ <DD>
+ Name of the collection list where the rule will be applied.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>ROLE</DT>
+ <DD>
+ Name of the Role used to reply a message.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>BCC</DT>
+ <DD>
+ Not implemented yet, but it will be implemented in future versions. It will
+ be used for <A HREF="h_config_compose_rules">compose</A>
+ <A HREF="h_config_reply_rules">reply</A>
+ <A HREF="h_config_forward_rules">forward</A>
+ rules.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>LCC</DT>
+ <DD>
+ This is the value of the Lcc: field at the moment that you start the composition.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>FORWARDFROM</DT>
+ <DD>
+ This corresponds to the personal name (or address if there's no personal
+ name) of the person who sent the message that you are forwarding.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>FORWARDADDRESS</DT>
+ <DD>
+ This is the address of the person that sent the message that you
+ are forwarding.
+ </DD>
+ </DL>
+ 
+ 
+ 
+ 
+ <DL>
+ <DT>FLAG</DT>
+ <DD> 
+ A string containing the value of all the flags associated to a specific
+ message. The possible values of allowed flags are "*" for Important, "N"
+ for recent or new, "U" for unseen or unread, "R" for seen or read, "A" for
+ answered and "D" for deleted. See an example of its use in the 
+ <A HREF="h_config_new_rules">new rules</A> explanation and example help.
+ </DD>
+ </DL>
+ 
+ <P>
  <H1><EM>Token Available Only for Templates and Signatures</EM></H1>
  
  <DL>
***************
*** 21001,21006 ****
--- 21101,21939 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_procid =====
+ <HTML>
+ <HEAD>
+ <TITLE>Token: PROCID</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>TOKEN: PROCID explained</H1>
+ 
+ <P>
+ The PROCID token is a way in which the user and the program can differentiate
+ between different parts of a program. It allows the user to tell the
+ program when to use a specific rule, and only use it at that specific
+ moment.
+ 
+ <P> The normal way in which this is done is by adding a new configuration 
+ variable. The idea behind the PROCID token is that instead of adding a new 
+ configuration variable (which means the user has to go through more 
+ configuration variables just to tune the program to his liking), we reuse 
+ an old variable and let the user look inside that variable for the desired
+ behavior, which is actually set by setting the PROCID token.
+ 
+ <P>
+ Consider the following examples for forward-rules:
+ 
+ <P>
+ _ROLE_ == {work} =&gt; _SUBJECT_ := _COPY_{[tag] _SUBJECT_}
+ 
+ <P>
+ and
+ 
+ <P>
+ _ROLE_ == {work} =&gt; _LCC_ := _TRIM_{_FORWARDFROM_ &lt;_FORWARDADDRESS_&gt;}
+ 
+ <P>
+ both are triggered by the same condition. Since both are configured in the 
+ same variable, only one of them will be executed all the time (whichever 
+ is first). Therefore in order to differentiate, we add a _PROCID_ token. 
+ So, for example, the first example above will be executed only when we are 
+ determining the subject. In this case, the following rule will accomplish 
+ this task
+ 
+ <P>
+ _PROCID_ == {fwd-subject} && _ROLE_ == {work} =&gt; _SUBJECT_ := _COPY_{[tag] _SUBJECT_}
+ 
+ <P>
+ In this case, this rule will be tested fully only when we are determining 
+ the subject line of a forwarded message, not otherwise.
+ 
+ <P>
+ It is wise to add the _PROCID_ token as the first condition in a rule, so 
+ that other conditions will not be tested in a long list of rules.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_compose_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Compose-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Compose-Rule</H1>
+ 
+ <P> At this time, this option is used to generate values for signature
+ files that is not possible to do with the use of 
+ <A HREF="h_rules_roles">roles</A>.
+ 
+ <P> For example, you can have a rule like:<BR>
+ _TO_ >> {Peter Flinstones} => _SIGNATURE_{~/.petersignature}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_forward_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Forward-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Forward-Rule</H1>
+ 
+ <P> This option has several uses. This feature uses the PROCID function
+ to identify different features of forwarding. You can read more about PROCID
+ by following <A HREF="h_config_procid">this link</A>.
+ 
+ <P> If you want to edit the subject of a forwarded message, use the
+ PROCID <I>fwd-subject</I>. For example you could have a rule like
+ 
+ <P>
+ _ROLE_ == {admin} && _SUBJECT_ !&gt; {[tag] } =&gt; _COPY_{[tag] _SUBJECT_}
+ 
+ <P> Another way in which this option can be used, is to trim the values of 
+ some fields. For this application the PROCID is <I>fwd-lcc</I>. For 
+ example it can be used in the following way:
+ 
+ <P>
+ _ROLE_ == {work} => _LCC_ := _TRIM_{_FORWARDFROM_ &lt;_FORWARDADDRESS_&gt;}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_index_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Index-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Index-Rule</H1>
+ 
+ <P> This option is used to supercede the value of the option <A
+ HREF="h_config_index_format">index-format</A> for specific folders. In
+ this form you can have different index-formats for different folders. For
+ example an entry here may be:
+ 
+ <P>
+ _FOLDER_ == {INBOX} => _INDEX_{IMAPSTATUS DATE FROM(33%) SIZE SUBJECT(67%)}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_pretty_command =====
+ <HTML>
+ <HEAD>
+ <TITLE>Pretty-Command Explained</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>Pretty Command Explained</H1>
+ 
+ <P> This text explains how to encode keys so that they will be recognized 
+ by Pine in the _PKEY_ token. Most direct keystrokes are recognized in the 
+ same way. For example, the key ~ is recognized by the same character. The 
+ issue is how control, or functions keys are recognized. The internal code 
+ is most times easy to find out. If the key you want to use is not already 
+ recognized by Pine simply press it. Pine will print its code. For example, 
+ the return key is not recognized in this screen, so if you press it, you 
+ will see the following message.
+ 
+ <P> [Command &quot;RETURN&quot; not defined for this screen. Use ? for help]
+ 
+ <P> from here you can guess that the code for the return command is 
+ RETURN. You can try other commands, like Control-C, the TAB key, F4, etc. 
+ to see their codes.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_key_macro_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Key-Definition-Rules</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Key-Definition-Rules</H1>
+ 
+ <P> This option can be used to define macros, that is, to define a key that
+ when pressed executes a group of predetermined keystrokes. Because Pine is
+ a menu driven program, sometimes the same key may have different meanings
+ in different screens, so a global redefinition of a key although possible
+ is not advisable. 
+ 
+ <P> <B>Always use the _SCREEN_ token as defined below.</B>. You have been
+ warned!
+ 
+ <P> In each screen, every time you press a recognized key a command is 
+ activated. In order to understand this feature, think of commands instead 
+ of keystrokes. For example, you can think of the sort by thread command. 
+ This command is associated to the keystrokes $ and h. You may want to 
+ associate this command to a specific keystroke, like ~, so every time you
+ press the ~ key, Pine understand the $ and h keystrokes, which activates
+ the sort by thread command.
+ 
+ <P> Therefore, in order to use this option you must think of three 
+ components. The screen where you will use the macro, the keystroke you 
+ want to use and the set of keystrokes used by Pine to accomplish the task 
+ you want to accomplish. We will talk about these three components in what 
+ follows.
+ 
+ <P> First you must decide in which screen the macro will be used. This 
+ feature is currently only available for the screen where your messages
+ are listed in index form (<A HREF="h_mail_index">MESSAGE INDEX</A>),
+ the screen where your message is displayed
+ (<A HREF="h_mail_view">MESSAGE TEXT</A>) and the screen where the list of
+ folders is displayed (<A HREF="h_folder_maint">FOLDER LIST</A>). The 
+ internal names of these screens for this patch are &quot;index&quot;, 
+ &quot;text&quot; and 
+ &quot;folder&quot; respectively. Please note that the internal names are 
+ all in lowercase are are case sensitive.
+ 
+ <P> In order to define the screen, you use the _SCREEN_ token, so for 
+ example, you can write _SCREEN_ == {index}.
+ 
+ <P> Second you must think of which key you will use to activate the macro. 
+ Here you can use any key of your choice. The token you use to designate a 
+ key is the _PKEY_ token (PKEY stands for &quot;pressed key&quot;). For 
+ example you could use _PKEY_ == {~}, to designate the &quot;~&quot; 
+ character to activate the command. Some keystrokes (like control, or 
+ function keys) are encoded in special ways. You should read the 
+ <A HREF="h_config_pretty_command">full explanation</A> on how to find
+ out the encoding for each keystroke.
+ 
+ <P> Last, you must think of the list of keys you will use to accomplish 
+ the task you want Pine to perform. Say for example you want to have the 
+ folder sorted by thread. That means you want Pine to execute the keys 
+ &quot;$&quot; and &quot;h&quot;. You use the _COMMAND_ function to specify 
+ this. The syntax in this case is _COMMAND_{$,h}.
+ 
+ <P> Observe that in the above example the different inputs are separated 
+ by commas. This is the standard way in which the 
+ <A HREF="h_config_init_cmd_list">initial-keystroke</A> command works from 
+ the command line. Due to restrictions in the way Pine works, a comma is a 
+ special character, which when added to a configuration option like this 
+ will cause the configuration to split into several lines in the 
+ configuration screen. This has the effect of producing several 
+ configuration options, all of which are incorrect. This is undesirable 
+ because what you want is to have it all in one line. In order to force the 
+ configuration into one line you must quote the comma. The best way to 
+ accomplish this is by quoting the full definition of the rule. For 
+ example.
+ 
+ <P>
+ &quot;_SCREEN_ == {index} && _PKEY_ == {~} => _COMMAND_{$,h}&quot;
+ 
+ <P> Another way to accomplish the same effect is by quoting the command and 
+ not using quotes for the full command, nor commas to separate the 
+ keystrokes in the command, for example
+ 
+ <P>
+ _SCREEN_ == {index} && _PKEY_ == {~} => _COMMAND_{&quot;$h&quot;}
+ 
+ <P> For more information on how to define the argument of the _COMMAND_
+ token see the help of 
+ <A HREF="h_config_init_cmd_list">initial-keystroke</A>.
+ 
+ <P> Because the $ command can also be used as the first character in the
+ definition of an environemnt variable, no expansion of environment variables
+ is done when parsing this variable. The $ character does not need quoting
+ and quoting it will make Pine fail to produce the correct result.
+ 
+ <P> This configuration option is just one of many that allow you to 
+ override the value of some global configurations within Pine. There is a 
+ help text explaining how to define all of them, which you can read by 
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_replace_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Replace-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Replace-Rule</H1>
+ 
+ <P> This option is used to have Pine print different values for specific 
+ tokens in the <A HREF="h_config_index_format">index-format</A>. For example you
+ can replace strings like "To: newsgroup" by your name.
+ 
+ <P> Here are examples of possible rules:<BR>
+ _FOLDER_ != {sent-mail} && _NICK_ != {} => _FROM_ := _REPLACE_{_FROM_ (_NICK_)}
+ 
+ <P> or if you receive messages with tags that contain arbitrary numbers, and
+ you want them removed from the index (but not from the subject), use a rule
+ like the following<BR>
+ _FOLDER_ == {INBOX} => _SUBJECT_ := _REXTRIM_{&#92;[some-tag-here #[0-9].*&#92;]}
+ 
+ <P> You can also use this configuration option to remove specific strings of
+ the index display screen, so that you can trim unnecessary information in
+ your index.
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_reply_leadin_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Reply-Leadin-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Reply-Leadin-Rule</H1>
+ 
+ <P> This option is used to have Pine generate a different 
+ <A HREF="h_config_reply_intro">reply-leadin</A> string dependent either on
+ the person you are replying to, or the folder where the message is being
+ replied is in, or both.
+ 
+ <P> Here there are examples of how this can be used. One can use the definition
+ below to post to newsgroups and the pine-info mailing list, say:
+ <P>
+ _FOLDER_ << {pine-info;_NEWS_} => _REPLY_{*** _FROM_ _ADDRESS_("_FROM_"  "" "(_ADDRESS_) ")wrote in_NEWS_("" " the" "") _FOLDER_ _NEWS_("" "list " "")_SMARTDATE_("Today" "today" "on _LONGDATE_"):}
+ 
+ <P> Here there is an example that one can use to change the reply indent string
+ to reply people that speak spanish.
+ <P>
+ _FROM_{Condorito;Quico} => _REPLY_{*** _FROM_ (_ADDRESS_) escribi&oacute; _SMARTDATE_("Today" "hoy" "en _LONGDATE_"):}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_resub_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Replace-Subject-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Replace-Subject-Rule</H1>
+ 
+ <P> This option is used to have Pine generate a different subject when
+ replying rather than the one Pine would generate automatically. 
+ 
+ <P> Here there are a couple of examples about how to use this
+ configuration option:
+ 
+ <P> In order to have messages with empty subject to be replied with the message
+ "your message" use the rule<BR>
+ <center>_SUBJECT_ == {} => _RESUB_{Re: your message}</center>
+ 
+ <P> If you want to trim some parts of the subject when you reply use the
+ rule<BR> 
+ <center>_SUBJECT_ >> {[one];two} => _SUBJECT_ := _TRIM_{[;];two}</center> 
+ 
+ <P>this rule removes the brackets "[" and "]" whenever the string "[one]"
+ appears in it, it also removes the word "two" from it.
+ 
+ <P>Another example where you may want to use this rule is when you 
+ correspond with people that change the reply string from &quot;Re:&quot; 
+ to &quot;AW:&quot; or &quot;Sv:&quot;. In this case a rule like<BR>
+ <center>_SUBJECT_ >> {Sv: ;AW: } => _SUBJECT_ := _TRIM_{Sv: ;AW: }</center> 
+ <P>
+ would eliminate undesired strings in replies.
+ 
+ <P> You can also use this configuration option to customize reply subjects
+ according to the sender of the message.
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_sort_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Sort-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Sort-Rule</H1>
+ 
+ <P> This option is used to have Pine sort different folders in different orders
+ and thus override the value already set in the
+ <A HREF="h_config_sort_key">sort-key</A> configuration option.
+ 
+ <P> Here's an example of the way it can be used. In this case all incoming
+ folders are mailing lists, except for INBOX, so we sort INBOX by arrival
+ (which is the default type of sort), but we want all the rest of mailing
+ lists and newsgroups to be sorted by thread.
+ 
+ <P>
+ _COLLECTION_ >> {Incoming-Folders;News} && _FOLDER_ != {INBOX} => _SORT_{tHread}
+ 
+ <P> Another example could be<BR>
+ _FOLDER_ == {Mailing List} => _SORT_{Reverse tHread}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ 
+ </BODY>
+ </HTML>
+ ====== h_config_save_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Save-Rules</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Save-Rules</H1>
+ 
+ <P> This option is used to specify which folder should be used to save a
+ message depending either on the folder the message is in, who the message
+ is from, or text that the message contains in specific headers (Cc:,
+ Subject:, etc).
+ 
+ <P> If this option is set and the 
+ <A HREF="h_config_auto_read_msgs">auto-move-read-msgs</A> configuration
+ option is also set then these definitions will be used to move messages
+ from your INBOX when exiting Pine.
+ 
+ <P>Here there are some examples<BR>
+ _FLAG_ >> {D} -> Trash<BR>
+ _FROM_ == {U2} -> Bono<BR>
+ _FOLDER_ == {comp.mail.pine} -> pine-stuff<BR>
+ _NICK_ != {} -> _NICK_/_NICK_<BR>
+ _DATEISO_ >> {02-10;02-11} -> archive-oct-nov-2002
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ 
+ </BODY>
+ </HTML>
+ ====== h_config_reply_indent_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Reply-indent-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Reply-indent-Rule</H1>
+ 
+ <P> This option is used to specify which reply-indent-string is to be used
+ when replying to an e-mail. If none of the rules are successful, the result in
+ the variable <a href="h_config_reply_indent_string">reply-indent-string</a>
+ is used.
+ 
+ <P> The associated function to this configuration option is called "RESTR" (for
+ REply STRing). Some examples of its use are:<BR>
+ _FROM_ == {Your Boss} => _RESTR_{"> "}<BR>
+ _FROM_ == {My Wife} => _RESTR_{":* "}<BR>
+ _FROM_ == {Perter Flinstone;Wilma Flinstone} => _RESTR_{"_INIT_ > "}<BR>
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ 
+ </BODY>
+ </HTML>
+ ====== h_config_smtp_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: SMTP-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: SMTP-Rule</H1>
+ 
+ <P> This option is used to specify which SMTP server should be used when
+ sending a message, if this rule is not defined, or the execution of the rule
+ results in no server selected, then Pine will look for 
+ the value from the role that is being used to compose the message. If no smtp
+ server is defined in that role or you are not using a role, then Pine will get
+ the name of the server from the
+ <A HREF="h_config_smtp_server">&quot;smtp-server&quot;</A> configuration
+ option according to the rules used in that variable.
+ 
+ <P> The function associated to this configuration option is _SMTP_, an example
+ of the use of this function is<BR>
+ _ADDRESSTO_ == {peter@bedrock.com} => _SMTP_{smtp.bedrock.com}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ 
+ </BODY>
+ </HTML>
+ ====== h_config_startup_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Startup-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Startup-Rule</H1>
+ 
+ <P> This option is used when a folder is being opened. You can use it to 
+ specify its <A HREF="h_config_inc_startup">incoming-startup-rule</A> and override
+ Pine's global value set for all folders.
+ 
+ <P> An example of the usage of this option is:<BR>
+ _FOLDER_ == {Lynx;pine-info;_NEWS_} => _STARTUP_{first-unseen}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ 
+ </BODY>
+ </HTML>
+ ====== h_config_new_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: New Rules Explained</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: New Rules Explained</H1>
+ 
+ This is a quite powerful option. Here you can define rules that override
+ the values of any other option you have set in Pine.
+ 
+ <P>
+   For example, you can set your folders to be sorted in a certain way when 
+ you open them (say by Arrival). You may want, however, your newsgroups to 
+ be sorted by thread. The set of &quot;rules&quot; options allows you to 
+ configure this and many other options, including the index-format for 
+ specific folders, the way the subject is displayed in the index screen or 
+ the reply-leadin-string, to name a few.
+ 
+ <P>
+   Every rule has three parts: a condition, a separator and an action. The
+ action is what will happen if the condition of the rule is satisified.
+ 
+ <P>
+   Here is an example:
+ 
+ <P>
+    _FROM_ == {Fred Flinstone} =&gt; _SAVE_{Fred}
+ 
+ <P>
+   Here the separator is "=&gt;". Whatever is to the left of the separator 
+ is the condition (that is _FROM_ == {Fred Flinstone}) and to the right is 
+ the action (_SAVE_{Fred}). The condition means that the rule will be 
+ applied only if the message that you are reading is from &quot;Fred 
+ Flinstone&quot;, and the action will be that you will be offered to save 
+ it in the folder &quot;Fred&quot;, whenever you press the letter 
+ &quot;S&quot; to save a message.
+ 
+ <P>
+   The separator is always &quot;=&gt;&quot;, with one exception to be seen 
+ later. But for the most part this will be the only one you will ever need.
+ 
+ <P>
+   Now let us see how to do it. There are 12 functions already defined for 
+ you. These are: _INDEX_, _REPLACE_, _REPLY_, _RESUB_, _SAVE_, _SIGNATURE_, 
+ _SORT_, _STARTUP_, _TRIM_, _REXTRIM_, _THREADSTYLE and _THREADINDEX_. The 
+ parameter of a function has to be enclosed between &quot;{&quot; and 
+ &quot;}&quot;, so for example you can specify _SAVE_{saved-messages} as a 
+ valid sentence.
+ 
+ <P>
+   Later in the document you will find examples. Here is a short 
+ description of what each function does:
+ 
+ <P>
+ <UL>
+ <LI> _INDEX_ : This function takes as an argument an index-format, and
+ makes that the index-format for the specified folder.
+ <BR>&nbsp;<BR>
+ <LI> _REPLACE_ : This function replaces the subject/from of the given e-mail by
+ another subject/from only when displaying the index.
+ <BR>&nbsp;<BR>
+ <LI> _REPLY_ : This function takes as an argument a definition of a
+ reply-leadin-string and makes this the reply-leading-string of the
+ specified folder or person.
+ <BR>&nbsp;<BR>
+ <LI> _RESTR_ : This function takes as an argument the value of the 
+ reply-indent-string to be used to answer the message being replied to.
+ <BR>&nbsp;<BR>
+ <LI> _RESUB_ : This function replaces the subject of the given e-mail by
+ another subject only when replying to a message.
+ <BR>&nbsp;<BR>
+ <LI> _SAVE_ : The save function takes as an argument the name of a
+ possibly non existing folder, whenever you want to save a message, that
+ folder will be offered for you to save.
+ <BR>&nbsp;<BR>
+ <LI> _SIGNATURE_ : This function takes as an argument a signature file and
+ uses that file as the signature for the message you are about to
+ compose/reply/forward.
+ <BR>&nbsp;<BR>
+ <LI> _SMTP_ : This function takes as an argument the definition of a
+ SMTP server.
+ <BR>&nbsp;<BR>
+ <LI> _SORT_ : This function takes as an argument a Sort Style, and sorts a
+ specified folder in that sort order.
+ <BR>&nbsp;<BR>
+ <LI> _TRIM_ : This function takes as an argument a list of strings that
+ you want removed from another string. At this time this only works for
+ _FROM_ and _SUBJECT_.
+ <BR>&nbsp;<BR>
+ <LI> _REXTRIM_ : Same as _TRIM_ but its argument is one and
+ only one extended regular expression.
+ <BR>&nbsp;<BR>
+ <LI> _STARTUP_ : This function takes as an argument an
+ incoming-startup-rule, and open an specified folder using that rule.
+ <BR>&nbsp;<BR>
+ <LI> _THREADSTYLE_ : This function takes as an argument a
+ threading-display-style and uses it to display threads in a folder.
+ <BR>&nbsp;<BR>
+ <LI> _THREADINDEX_ : This function takes as an argument a
+ threading-index-style and uses it to display threads in a folder.
+ </UL>
+ 
+ <P>
+ You must me wondering how to define the person/folder over who to apply
+ the action. This is done in the condition. When you specify a rule, the
+ rule is only executed if the condition is satisfied. In another words for
+ the rule:
+ 
+ <P>
+    _FROM_ == {Fred Flinstone} =&gt; _SAVE_{Fred}
+ 
+ <P> it will only be applied if the from is &quot;Fred Flinstone&quot;. If 
+ the From is &quot;Wilma Flinstone&quot; the rule will be skipped.
+ 
+ <P> In order to test a condition you can use the following tokens (in 
+ alphabetical order): _ADDRESS_, _CC_, _FOLDER_, _FROM_,_NICK_, _ROLE, 
+ _SENDER_, _SUBJECT_ and _TO_. The token will always be tested against what 
+ it is between &quot;{&quot; and &quot;}&quot; in the condition, this part 
+ of the condition is called the &quot;condition set&quot;. The definition 
+ of each token can be found <A HREF="h_index_tokens">here</A>. 
+ 
+ <P> A special testing token called _PROCID_ can be used to differentiate 
+ inside a rule, between two rules that are triggered by the same condition. 
+ A full explanation of the _PROCID_ token can be found in 
+ <A HREF="h_config_procid">this link</A>.
+ 
+ <P> There are two more tokens related to the option
+ <A HREF="h_config_key_macro_rules">key-definition-rules</A>. Those tokens
+ are only specific to that option, and hence are not explained here.
+ 
+ <P> You can also test in different ways, you can use the following 
+ &quot;test operands&quot;: &lt;&lt;, !&lt;, &gt;&gt;, !&gt;, == and !=. 
+ All of them are two strings long. Here is the meaning of them:
+ 
+ <P>
+ <UL> 
+ <LI> &lt;&lt; : It tests if the value of the token is contained in
+ the condition set. Here for example if the condition set were equal to
+ &quot;Freddy&quot;, then the condition: _NICK_ &lt;&lt; {Freddy}, would be true if
+ the value of _NICK_ were &quot;Fred&quot;, &quot;red&quot; or &quot;Freddy&quot;. You are just looking
+ for substrings here.
+ <LI> &gt;&gt; : It tests if the value of the token contains the value of
+ the condition set. Here for example if the condittion set were equal to
+ &quot;Fred&quot;, then the condition: _FROM_ &gt;&gt; {Fred}, would be true if
+ the value of _FROM_ were &quot;Fred Flinstone&quot; or &quot;Fred P. Flinstone&quot; or &quot;Freddy&quot;.
+ <LI> == : It tests if the value of the token is exactly equal to the value
+ of the set condition. For example _NICK_ == {Fred} will be false if the value 
+ of _NICK_ is &quot;Freddy&quot; or &quot;red&quot;. 
+ <LI> !&lt; : This is true only when &lt;&lt; is false and viceversa.
+ <LI> !&gt; : This is true only when &gt;&gt; is false and viceversa.
+ <LI> != : This is true only when == is false and viceversa.
+ </UL>
+ 
+ <P>
+   Now let us say that you want the same action to be applied to more than
+ one person or folder, say you want &quot;folder1&quot; and &quot;folder2&quot; to be sorted by
+ Ordered Subject upon entering. Then you can list them all of them in the
+ condition part separting them by a &quot;;&quot;. Here is the way to do it.
+ 
+ <P>
+  _FOLDER_ &lt;&lt; {folder1; folder2} =&gt; _SORT_{OrderedSubj}
+ 
+ <P>
+   Here is the first subtelty about these definitions. Notice that the
+ following rule:
+ 
+ <P>
+  _FOLDER_ == {folder1; folder2} =&gt; _SORT_{Reverse OrderedSubj}
+ 
+ <P> works only for &quot;folder1&quot; but not for &quot;folder2&quot;. This is because the
+ comparison of the name of the folder is done with whatever is in between
+ &quot;{&quot;, &quot;;&quot; or &quot;}&quot;, so in the above rule you would be testing <BR>
+ &quot;folder2&quot; == &quot; folder2&quot;. The extra space makes the difference. 
+ The reason why the first rule does not fail is because 
+ &quot;folder2&quot; &lt;&lt; &quot; folder2&quot; is actually
+ true. If something ever fails this may be something to look into.
+ 
+ <P>
+  Here are a few examples of what we have talked about before.
+ 
+ <P>
+ _NICK_ == {lisa;kika} =&gt; _SAVE_{_NICK_/_NICK_} <BR>
+ This means that if the nick is lisa, it will 
+ save the message in the folder &quot;lisa/lisa&quot;, and if the nick 
+ is &quot;kika&quot;, it will save the message in the folder &quot;kika/kika&quot;
+ 
+ <P>
+ _FOLDER_ == {Lynx} -&gt; lynx <BR>
+ This, is an abreviation of the following rule:<BR>
+ _FOLDER_ == {Lynx} =&gt; _SAVE_{lynx} <BR>
+ (note the change in separator from &quot;=&gt;&quot; to &quot;-&gt;&quot;). In the future 
+ I will use that abreviation.
+ 
+ <P> _FOLDER_ &lt;&lt; {comp.mail.pine; pine-info; pine-alpha} -&gt; pine <BR>
+ Any message in the folders &quot;comp.mail.pine&quot;, &quot;pine-info&quot; or &quot;pine-alpha&quot;
+ will be saved to the folder &quot;pine&quot;.
+ 
+ <P> _FROM_ &lt;&lt; {Pine Master} -&gt; pine <BR>
+ Any message whose From field contains
+ &quot;Pine Master&quot; will be saved in the folder pine.
+ 
+ <P> _FOLDER_ &lt;&lt; {Lynx; pine-info; comp.mail.pine} =&gt;
+ _INDEX_{IMAPSTATUS MSGNO DATE FROMORTO(33%) SUBJECT(66%)} <BR> Use a
+ different index-format for the folders &quot;Lynx&quot;, &quot;pine-info&quot; and
+ &quot;comp.mail.pine&quot;, where the size is not present.
+ 
+ <P> _FOLDER_ == {Lynx;pine-info} =&gt; _REPLY_{*** _FROM_ (_ADDRESS_)
+ wrote in the _FOLDER_ list _SMARTDATE_(&quot;Today&quot; &quot;today&quot; &quot;on
+ _LONGDATE_&quot;):}<BR> If a message is in one of the incoming folders &quot;Lynx&quot;
+ or &quot;pine-info&quot;, create a reply-leadin-string that acknowledges that. Note
+ the absence of &quot;,&quot; in the function _SMARTDATE_. For example answering to a
+ message in the pine-info list would look like:
+ 
+ <P>
+ *** Steve Hubert (hubert@cac.washington.edu) wrote in the pine-info list today:
+ 
+ <P>
+ However replying for a message in the Lynx list would look:
+ 
+ <P>
+ *** mattack@area.com (mattack@area.com) wrote in the Lynx list today:
+ 
+ <P>
+ If you write in more than one language you can use this feature to create
+ Reply-leadin-strings in different languages.
+ 
+ <P> Note that at least for people you can create particular
+ reply-leadin-string using the role features, but it does not work as this
+ one does. This seems to be the right way to do it.
+ 
+ <P> _FOLDER_ &lt;&lt; {Lynx; comp.mail.pine; pine_info; pine-alpha} =&gt;
+ _SORT_{OrderedSubj}<BR> This means upon opening, sort the folders &quot;Lynx&quot;,
+ &quot;comp.mail.pine&quot;, etc in ordered subject. All the others use the default
+ sort order. You can not sort in reverse in this form. The possible
+ arguments of this function are listed in the definition of the
+ default-sort-rule (Arrival, scorE, siZe, etc).
+ 
+ <P> The last examples use the function _TRIM_ which has a special form.
+ This function can only be used in the index list.
+ 
+ <P> _FOLDER_ &lt;&lt; {Lynx} =&gt; _SUBJECT_ := _TRIM_{lynx-dev }<BR> In
+ the folder &quot;Lynx&quot; eliminate from the subject the string &quot;lynx-dev &quot; (with
+ the space at the end). For example a message whose subject is &quot;Re:
+ lynx-dev unvisited Visited Links&quot;, would be shown in the index with
+ subject: &quot;Re: unvisited Visited Links&quot;, making the subject shorter and
+ giving the same information.
+ 
+ <P> _FROM_ &gt;&gt; {Name (Comment)} =&gt; _FROM_ :=
+ _TRIM_{ (Comment)}<BR> Remove the part &quot; (Comment)&quot;
+ from the _FROM_, so when displaying in the index the real From &quot;Name&quot;
+ will appear.
+ 
+ <P> _SUBJECT_ == {} =&gt; _RESUB_{Re: your mail without subject}
+ If there is no subject in the message, use the subject &quot;Re: your mail
+ wiyhout subject&quot; as a subject for the reply message.
+ 
+ <P> You can add more complexity to your rules by checking more than one
+ conditions before a rule is executed. For example: Assume that you want to
+ answer every email that contains the string &quot;bug report&quot;, with the subject
+ &quot;Re: About your bug report&quot;, you could make
+ 
+ <P>
+ _SUBJECT_ == {bug report} =&gt; _RESUB_{Re: About your _SUBJECT_}
+ 
+ <P> The problem with this construction is that if the person emails you
+ back, then the next time you answer the message the subject will be: &quot;Re:
+ About your Re: About your bug report&quot;, so it grew. You may want to avoid
+ this growth by using the following rule:
+ 
+ <P>
+ _SUBJECT_ &gt;&gt; {bug report} &&  _SUBJECT_ !&gt; {Re: } =&gt; _RESUB_{Re: About your _SUBJECT_}<BR>
+ 
+ <P>
+ which will only add the string &quot;Re: About your&quot; only the first time the
+ message is replied.
+ 
+ <P>
+   Say your personal name is &quot;Fred Flinstones&quot;, and assume that you don't
+ like to see &quot;To: comp.mail.pine&quot; in every post you make to this newsgroup,
+ but instead would like to see it as everyone else sees it. <BR> 
+ _FOLDER_ == {comp.mail.pine} && _FROM_ == {Fred Flinstones} => _FROM_ := _REPLACE_{_FROM_}
+ 
+ <P> 
+   You can also list your index by nick, in the following way:<BR>
+ _NICK_ != {} => _FROM_ := _REPLACE_{_NICK_}
+ 
+ <P>
+   If you want to open the folder &quot;pine-info&quot; in the first non-read message
+ use the rule:<BR>
+ _FOLDER_ == {pine-info} => _STARTUP_{first-unseen}
+ 
+ <P>
+  If you want to move your deleted messages to a folder, called &quot;Trash&quot;, use
+ the following rule:<BR>
+ _FLAG_ >> {D} -> Trash
+ 
+ <P>
+ The reason why the above test is not &quot;_FLAG_ == {D}&quot; is because that would mean
+ that this is the only flag set in the message. It's better to test by containment in this case.
+ 
+ <P> If you want to use a specific signature when you are in a specific collection
+ use the following rule:<BR>
+ _COLLECTION_ == {Mail} => _SIGNATURE_{/full/path/to/.signature}
+ 
+ <P> Finally about the question of which rule will be executed. Only the
+ first rule that matches will be executed. It is important to notice though
+ that &quot;saving&quot; rules do not compete with &quot;sorting&quot; rules. So the first
+ &quot;saving&quot; rule that matches will be executed in the case of saving and so
+ on.
+ 
+ <P>
+ <UL>
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_char_set =====
  <HTML>
  <HEAD>
***************
*** 24226,24231 ****
--- 25159,25234 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_thread_display_style_rule =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Threading-Display-Style-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Threading-Display-Style-Rule</H1>
+ 
+ This option is very similar to <A HREF="h_config_thread_disp_style">
+ threading-display-style</A>, but it is a rule which specifies the
+ display styles for a thread that you want displayed in a specific
+ folder or collection.
+ <P>
+ The token to be used in this function is _THREADSTYLE_. Here there is
+ an example of its use
+ <P>
+ _FOLDER_ == {pine-info} => _THREADSTYLE_{mutt-like}
+ <P>
+ The values that can be given for the _THREADSTYLE_ function are the
+ values of the threading-display-style function, which can be found
+ listed in the <A HREF="h_config_thread_disp_style">threading-display-style</A>
+ configuration option.
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_thread_index_style_rule =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Threading-Index-Style-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Threading-Index-Style-Rule</H1>
+ 
+ This option is very similar to <A HREF="h_config_thread_index_style">
+ threading-index-style</A>, but it is a rule which specifies the
+ index styles for a thread that you want displayed in a specific
+ folder or collection.
+ <P>
+ The token to be used in this function is _THREADINDEX_. Here there is
+ an example of its use
+ <P>
+ _FOLDER_ == {pine-info} => _THREADINDEX_{regular-index-with-expanded-threads}
+ <P>
+ The values that can be given for the _THREADINDEX_ function are the
+ values of the threading-index-display function, which can be found
+ listed in the <A HREF="h_config_thread_index_style">threading-index-display</A>
+ configuration option.
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Pine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_pruning_rule =====
  <HTML>
  <HEAD>
***************
*** 27331,27336 ****
--- 28334,28362 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_auto_read_msgs_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: auto-move-read-msgs-using-rules</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: auto-move-read-msgs-using-rules</H1>
+ This feature controls an aspect of Pine's behavior upon quitting.  If set,
+ and the 
+ <A HREF="h_config_read_message_folder">&quot;read-message-folder&quot;</A>
+ option is also set, then Pine will automatically transfer all read
+ messages to the designated folder using the rules that you have defined in
+ your
+ <A HREF="h_config_save_rules">&quot;save-rules&quot;</A> and mark
+ them as deleted in the INBOX.  Messages in the INBOX marked with an 
+ &quot;N&quot; (meaning New, or unseen) are not affected.
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_auto_fcc_only =====
  <HTML>
  <HEAD>
diff -rc pine4.64/pine/reply.c pine4.64.rules/pine/reply.c
*** pine4.64/pine/reply.c	Mon Sep 12 15:04:25 2005
--- pine4.64.rules/pine/reply.c	Mon Oct 16 11:58:22 2006
***************
*** 319,326 ****
  		outgoing->subject = cpystr("Re: several messages");
  	    }
  	}
! 	else
! 	  outgoing->subject = reply_subject(env->subject, NULL, 0);
      }
  
  
--- 319,336 ----
  		outgoing->subject = cpystr("Re: several messages");
  	    }
  	}
! 	else{
! 	   RULE_RESULT *rule;
! 	   rule = get_result_rule(V_RESUB_RULES,FOR_RESUB|FOR_TRIM , env);
! 	   if (rule){
! 	     outgoing->subject = reply_subject(rule->result, NULL, 0);
! 	     if (rule->result)
! 	        fs_give((void **)&rule->result);
! 	     fs_give((void **)&rule);
! 	   }
! 	   else
! 	       outgoing->subject = reply_subject(env->subject, NULL, 0);
! 	}
      }
  
  
***************
*** 331,336 ****
--- 341,349 ----
      if(sp_expunge_count(pine_state->mail_stream))	/* cur msg expunged */
        goto done_early;
  
+     if (ps_global->role)
+ 	fs_give((void **)&ps_global->role);
+ 
      /* Setup possible role */
      if(role_arg)
        role = copy_action(role_arg);
***************
*** 364,369 ****
--- 377,385 ----
  	}
      }
  
+     if (role)
+ 	ps_global->role = cpystr(role->nick); /* remember the role */
+ 
      /*
       * Reply_seed may call c-client in get_fcc_based_on_to, so env may
       * no longer be valid. Get it again.
***************
*** 1623,1630 ****
      ENVELOPE *env;
  {
      char *prefix, *repl, *p, buf[MAX_PREFIX+1], pbf[MAX_SUBSTITUTION+1];
  
!     strncpy(buf, ps_global->VAR_REPLY_STRING, sizeof(buf)-1);
      buf[sizeof(buf)-1] = '\0';
  
      /* set up the prefix to quote included text */
--- 1639,1665 ----
      ENVELOPE *env;
  {
      char *prefix, *repl, *p, buf[MAX_PREFIX+1], pbf[MAX_SUBSTITUTION+1];
+     char reply_string[MAX_PREFIX+1];
  
!     { RULE_RESULT *rule;
!       rule = get_result_rule(V_REPLY_INDENT_RULES, FOR_COMPOSE , env);
!        if (rule){
!            strncpy(reply_string,rule->result,sizeof(reply_string));
! 	   reply_string[sizeof(reply_string)-1] = '\0';
!            if (rule->result)
! 	      fs_give((void **)&rule->result);
! 	   fs_give((void **)&rule);
!        }
!        else
! 	  if ((ps_global->VAR_REPLY_STRING) && (ps_global->VAR_REPLY_STRING[0])){
! 	    strncpy(reply_string,ps_global->VAR_REPLY_STRING, sizeof(reply_string)-1);
! 	    reply_string[sizeof(reply_string)-1] = '\0';
! 	  }
! 	  else
!            strncpy(reply_string,"> ",sizeof("> "));
!     }
! 
!     strncpy(buf, reply_string, sizeof(buf)-1);
      buf[sizeof(buf)-1] = '\0';
  
      /* set up the prefix to quote included text */
***************
*** 1680,1689 ****
  int
  reply_quote_str_contains_tokens()
  {
!     return(ps_global->VAR_REPLY_STRING && ps_global->VAR_REPLY_STRING[0] &&
! 	   (strstr(ps_global->VAR_REPLY_STRING, from_token) ||
! 	    strstr(ps_global->VAR_REPLY_STRING, nick_token) ||
! 	    strstr(ps_global->VAR_REPLY_STRING, init_token)));
  }
  
  /*
--- 1715,1743 ----
  int
  reply_quote_str_contains_tokens()
  {
!    char *reply_string;
!       
!    reply_string = (char *) malloc( 80*sizeof(char));
!    { RULE_RESULT *rule;
!      rule = get_result_rule(V_REPLY_INDENT_RULES, FOR_COMPOSE, NULL);
!       if (rule){
!           reply_string = cpystr(rule->result);
! 	  if (rule->result)
! 	     fs_give((void **)&rule->result);
! 	  fs_give((void **)&rule);
!       }
!       else
! 	  if ((ps_global->VAR_REPLY_STRING) && (ps_global->VAR_REPLY_STRING[0])){
! 	    strncpy(reply_string,ps_global->VAR_REPLY_STRING, sizeof(reply_string)-1);
! 	    reply_string[sizeof(reply_string)-1] = '\0';
! 	  }
! 	  else
!           reply_string = cpystr("> ");
!    }
!     return(reply_string && reply_string[0] &&
! 	   (strstr(reply_string, from_token) ||
! 	    strstr(reply_string, nick_token) ||
! 	    strstr(reply_string, init_token)));
  }
  
  /*
***************
*** 2251,2256 ****
--- 2305,2314 ----
      buf[0] = '\0';
  
      switch(type){
+       case iFfrom:
+ 	addr = env && env->sparep ? env->sparep : NULL;
+ 	break;
+ 
        case iFrom:
  	addr = env ? env->from : NULL;
  	break;
***************
*** 2682,2702 ****
  
  	break;
  
        case iFrom:
        case iTo:
        case iCc:
        case iSender:
        case iRecips:
        case iInit:
  	get_addr_data(env, type, buf, maxlen);
  	break;
  
!       case iRoleNick:
! 	if(role && role->nick){
! 	    strncpy(buf, role->nick, maxlen);
! 	    buf[maxlen] = '\0';
! 	}
! 	break;
  
        case iAddress:
        case iMailbox:
--- 2740,2876 ----
  
  	break;
  
+       case iProcid:
+         if(ps_global->procid)
+ 	   sprintf(buf, ps_global->procid);
+       break;
+ 
+       case iRole:
+         if (ps_global->role)
+ 	   sprintf(buf, ps_global->role);
+       break;
+ 
+       case iRoleNick:
+ 	if(role && role->nick){
+ 	    strncpy(buf, role->nick, maxlen);
+ 	    buf[maxlen] = '\0';
+ 	}
+ 	break;
+ 
+       case iPkey:
+ 	  strcpy(buf, ps_global->pressed_key);
+ 	break;
+ 
+       case iScreen:
+ 	if (ps_global->prev_screen == mail_index_screen) strcpy(buf,"index");
+ 	else if(ps_global->prev_screen == folder_screen) strcpy(buf,"folder");
+ 	else if(ps_global->prev_screen == mail_view_screen) strcpy(buf,"text");
+ 	else sprintf(buf,"unknown");
+ 	break;
+ 
+       case iFfrom:
        case iFrom:
        case iTo:
        case iCc:
        case iSender:
        case iRecips:
        case iInit:
+       if (env)  
  	get_addr_data(env, type, buf, maxlen);
  	break;
  
!      case iFolder:
!       sprintf(buf,ps_global->cur_folder);
!       break;
! 
!      case iCollection:
!       sprintf(buf,ps_global->context_current->nickname);
!       break;
!       
!      case iFlag:
!         {MAILSTREAM *stream = find_open_stream();
! 	 MSGNO_S *msgmap = NULL;
!          long msgno;
!          MESSAGECACHE *mc;
! 	 strcpy(buf, "_FLAG_"); 	/* default value */
! 	 if (stream){
! 	     mn_init(&msgmap, stream->nmsgs);
! 	     msgno =  mn_m2raw(msgmap, rules_cursor_pos(stream));
! 	     if (msgno > 0L) mc = stream ? mail_elt(stream,  msgno) : NULL;
! 	     if (mc)
! 	        sprintf(buf,"%s%s%s%s",mc->flagged ? "*" : "",
!                 mc->recent   ? (mc->seen ? "R" : "N") : (mc->seen) ? "R" : "U",
!                 mc->answered ? "A" : "",
!                 mc->deleted  ? "D" : "" );
! 	     mn_give(&msgmap);
! 	 }
!         }
!         break;
!          
!      case iNick:
!      {
!       ADDRESS *tmp_adr = NULL;
!       if (env){
!          tmp_adr = env->from ? copyaddr(env->from)
!                      : env->sender ? copyaddr(env->sender) : NULL;
!          get_nickname_from_addr(tmp_adr,buf,maxlen);
! 	 mail_free_address(&tmp_adr);
!       }
!      }
!         break;
! 
!      case iAddressCc:
!      case iAddressRecip:
!      case iAddressTo:
!      case iFadd:
!      {
!      int plen = 0; 	/* partial length */
!      ADDRESS *sparep2 = (type == iAddressTo || type == iAddressRecip) 
! 			? ((env && env->to) 
! 			   ? copyaddrlist(env->to)
! 			   : NULL)
! 			: (type == iAddressCc)
! 			    ? ((env && env->cc) 
! 				? copyaddrlist(env->cc)
! 				: NULL)
! 			    : ((env && env->sparep) 
! 				? copyaddr((ADDRESS *)env->sparep)
! 				: NULL);
!       ADDRESS *sparep;
! 
!       if (type == iAddressRecip){
! 	  ADDRESS *last_to = NULL;
! 
! 	for(last_to = sparep2;last_to && last_to->next; last_to= last_to->next);
! 	
! 	/* Make the end of To list point to cc list */
! 	if(last_to)
! 	  last_to->next = (env && env->cc ? copyaddrlist(env->cc) : NULL);
! 
!       }
!       sparep = sparep2;
!       for(; sparep ; sparep = sparep->next)
! 	if(sparep && sparep->mailbox && sparep->mailbox[0] &&
! 	   (plen ? plen + 1 : plen) + strlen(sparep->mailbox) <= maxlen){
! 	   if (plen == 0)
! 	       strcpy(buf, sparep->mailbox);
! 	   else{
! 	       strcat(buf, " ");
! 	       strcat(buf, sparep->mailbox);
! 	   }
! 	   if(sparep->host &&
!         	   sparep->host[0] &&
! 		   sparep->host[0] != '.' &&
! 		   strlen(buf) + strlen(sparep->host) + 1 <= maxlen){
! 	      strcat(buf, "@");
!               strcat(buf, sparep->host);
!            }
! 	   plen = strlen(buf);
! 	}
! 	 mail_free_address(&sparep2);
!      }
!          
!       break;  
  
        case iAddress:
        case iMailbox:
***************
*** 2715,2720 ****
--- 2889,2899 ----
  
  	break;
  
+       case iLcc:	/* fake it, there are not enough spare pointers */
+ 	if (env && env->date)
+ 	  sprintf(buf,env->date);
+ 	break;
+ 
        case iNews:
        case iCurNews:
  	get_news_data(env, type, buf, maxlen);
***************
*** 2826,2832 ****
      if(!env)
        return;
  
!     strncpy(buf, ps_global->VAR_REPLY_INTRO, MAX_DELIM);
      buf[MAX_DELIM] = '\0';
      /* preserve exact default behavior from before */
      if(!strcmp(buf, DEFAULT_REPLY_INTRO)){
--- 3005,3022 ----
      if(!env)
        return;
  
!     { RULE_RESULT *rule;
! 	rule = get_result_rule(V_REPLY_LEADIN_RULES, FOR_REPLY_INTRO, env);
! 	if(rule){
! 	   strncpy(buf, rule->result, MAX_DELIM);
! 	   if (rule->result)
! 	      fs_give((void **)&rule->result);
! 	   fs_give((void **)&rule);
! 	}
! 	else
! 	  strncpy(buf, ps_global->VAR_REPLY_INTRO, MAX_DELIM);
!     }
! 
      buf[MAX_DELIM] = '\0';
      /* preserve exact default behavior from before */
      if(!strcmp(buf, DEFAULT_REPLY_INTRO)){
***************
*** 3051,3056 ****
--- 3241,3248 ----
  
      if(is_sig){
  	/*
+ 	 * First we check if there is a rule about signatures, if there is
+ 	 * use it, otherwise keep going and do the following:
  	 * If role->litsig is set, we use it;
  	 * Else, if VAR_LITERAL_SIG is set, we use that;
  	 * Else, if role->sig is set, we use that;
***************
*** 3064,3077 ****
  	 * there is no reason to mix them, so we don't provide support to
  	 * do so.
  	 */
! 	if(role && role->litsig)
! 	  literal_sig = role->litsig;
! 	else if(ps_global->VAR_LITERAL_SIG)
! 	  literal_sig = ps_global->VAR_LITERAL_SIG;
! 	else if(role && role->sig)
! 	  sigfile = role->sig;
! 	else
! 	  sigfile = ps_global->VAR_SIGNATURE_FILE;
      }
      else if(role && role->template)
        sigfile = role->template;
--- 3256,3280 ----
  	 * there is no reason to mix them, so we don't provide support to
  	 * do so.
  	 */
!         { RULE_RESULT *rule;
!            rule = get_result_rule(V_COMPOSE_RULES, FOR_COMPOSE, env);
!            if (rule){
!                sigfile = cpystr(rule->result);
! 	       if (rule->result)
! 	          fs_give((void **)&rule->result);
! 	       fs_give((void **)&rule);
! 	   }
!         }
! 	if (!sigfile){
! 	  if(role && role->litsig)
! 	    literal_sig = role->litsig;
! 	  else if(ps_global->VAR_LITERAL_SIG)
! 	    literal_sig = ps_global->VAR_LITERAL_SIG;
! 	  else if(role && role->sig)
! 	    sigfile = role->sig;
! 	  else
! 	    sigfile = ps_global->VAR_SIGNATURE_FILE;
! 	}
      }
      else if(role && role->template)
        sigfile = role->template;
***************
*** 3269,3275 ****
  			}
  		    }
  		}
! 		else if(pt->what_for & FOR_REPLY_INTRO)
  		  repl = get_reply_data(env, role, pt->ctype,
  					subbuf, sizeof(subbuf)-1);
  
--- 3472,3478 ----
  			}
  		    }
  		}
! 		else if(pt->what_for & (FOR_REPLY_INTRO | FOR_RULE))
  		  repl = get_reply_data(env, role, pt->ctype,
  					subbuf, sizeof(subbuf)-1);
  
***************
*** 3747,3755 ****
  	}
      }
  
!     if(role)
        q_status_message1(SM_ORDER, 3, 4,
  			"Forwarding using role \"%.200s\"", role->nick);
  
      if(role && role->template){
  	char *filtered;
--- 3950,3963 ----
  	}
      }
  
!     if (ps_global->role)
! 	fs_give((void **)&ps_global->role);
! 
!     if(role){
        q_status_message1(SM_ORDER, 3, 4,
  			"Forwarding using role \"%.200s\"", role->nick);
+       ps_global->role = cpystr(role->nick);
+     }
  
      if(role && role->template){
  	char *filtered;
***************
*** 3953,3958 ****
--- 4161,4167 ----
  #if	defined(DOS) && !defined(_WINDOWS)
      free((void *)reserve);
  #endif
+     outgoing->sparep = env && env->from ? (ADDRESS *)copyaddr(env->from) : NULL;
      pine_send(outgoing, &body, "FORWARD MESSAGE",
  	      role, NULL, reply.flags ? &reply : NULL, redraft_pos,
  	      NULL, NULL, FALSE);
***************
*** 4002,4007 ****
--- 4211,4217 ----
  {
      size_t l;
      char  *p, buftmp[MAILTMPLEN];
+     RULE_RESULT *rule;
      
      if(!env)
        return(NULL);
***************
*** 4009,4016 ****
      dprint(9, (debugfile, "checking subject: \"%s\"\n",
  	       env->subject ? env->subject : "NULL"));
  
!     if(env->subject && env->subject[0]){		/* add (fwd)? */
! 	sprintf(buftmp, "%.200s", env->subject);
  	/* decode any 8bit (copy to the temp buffer if decoding doesn't) */
  	if(rfc1522_decode((unsigned char *) tmp_20k_buf,
  		      SIZEOF_20KBUF, buftmp, NULL) == (unsigned char *) buftmp)
--- 4219,4237 ----
      dprint(9, (debugfile, "checking subject: \"%s\"\n",
  	       env->subject ? env->subject : "NULL"));
  
!     buftmp[0] = '\0';
!     ps_global->procid = cpystr("fwd-subject");
!     if (rule = get_result_rule(V_FORWARD_RULES,FOR_COMPOSE, env)){
!        sprintf(buftmp, "%.200s", rule->result);
!        if(rule->result)
! 	 fs_give((void **)&rule->result);
!        fs_give((void **)&rule);
!     }
!     else if(env->subject)
!        sprintf(buftmp, "%.200s", env->subject);
!     fs_give((void **)&ps_global->procid);
! 
!     if(buftmp[0]){		/* add (fwd)? */
  	/* decode any 8bit (copy to the temp buffer if decoding doesn't) */
  	if(rfc1522_decode((unsigned char *) tmp_20k_buf,
  		      SIZEOF_20KBUF, buftmp, NULL) == (unsigned char *) buftmp)
***************
*** 4019,4025 ****
  	removing_trailing_white_space(tmp_20k_buf);
  	if((l=strlen(tmp_20k_buf)) < 1000 &&
  	   (l < 5 || strcmp(tmp_20k_buf+l-5,"(fwd)"))){
! 	    sprintf(tmp_20k_buf+2000, "%s (fwd)", env->subject);
  	    strcpy(tmp_20k_buf, tmp_20k_buf+2000);
  	}
  
--- 4240,4246 ----
  	removing_trailing_white_space(tmp_20k_buf);
  	if((l=strlen(tmp_20k_buf)) < 1000 &&
  	   (l < 5 || strcmp(tmp_20k_buf+l-5,"(fwd)"))){
! 	    sprintf(tmp_20k_buf+2000, "%s (fwd)", buftmp);
  	    strcpy(tmp_20k_buf, tmp_20k_buf+2000);
  	}
  
diff -rc pine4.64/pine/rules.c pine4.64.rules/pine/rules.c
*** pine4.64/pine/rules.c	Tue Oct 17 07:59:14 2006
--- pine4.64.rules/pine/rules.c	Sun Oct 15 00:21:36 2006
***************
*** 0 ****
--- 1,965 ----
+ /* This module was written by
+  *
+  * Eduardo Chappa (chappa@math.washington.edu)
+  * http://www.math.washington.edu/~chappa/pine/
+  *
+  *  Original Version: November 1999
+  *  Last Modified   : December 14, 2004
+  *
+  * Send bug reports about this module to the address above.
+  */
+ 
+ #include "rules.h"
+ 
+ int context_for_function(name)
+    char *name;
+ {
+   int i, j;
+   for (i = 0; i < NFCN && strcmp(rule_fcns[i].name, name); i++);
+   return i == NFCN ? 0 : rule_fcns[i].what_for;
+ 
+ }
+ 
+ char **functions_for_token(name)
+    char *name;
+ {
+   int i;
+   for (i = 0; i < NFCNFI && strcmp(fcns_for_index[i][0], name); i++);
+   return i == NFCNFI ? NULL : fcns_for_index[i];
+ }
+ 
+ void free_token_value(token)
+   TOKEN_VALUE **token;
+ {
+    if(token && *token){
+      if ((*token)->testxt)
+ 	fs_give((void **)&((*token)->testxt));
+      if((*token)->next)
+ 	free_token_value(&((*token)->next));
+      fs_give((void **)token);
+    }
+ }
+ 
+ void free_condition(condition)
+   CONDITION_S **condition;
+ {
+    if(condition && *condition){
+      if ((*condition)->tname)
+ 	fs_give((void **)&((*condition)->tname));
+      if ((*condition)->value)
+ 	free_token_value(&((*condition)->value));
+      if((*condition)->next)
+ 	free_condition(&((*condition)->next));
+      fs_give((void **)condition);
+    }
+ }
+ 
+ void free_ruleaction(raction)
+   RULEACTION_S **raction;
+ {
+    if(raction && *raction){
+      if ((*raction)->token)
+ 	fs_give((void **)&((*raction)->token));
+      if ((*raction)->function)
+ 	fs_give((void **)&((*raction)->function));
+      if ((*raction)->value)
+ 	fs_give((void **)&((*raction)->value));
+      fs_give((void **)raction);
+    }
+ }
+ 
+ void free_rule(rule)
+   RULE_S **rule;
+ {
+    if(rule && *rule){
+      free_condition(&((*rule)->condition));
+      free_ruleaction(&((*rule)->action));
+      fs_give((void **)rule);
+    }
+ }
+ 
+ void free_rule_list(rule)
+   RULELIST **rule;
+ {
+   if(!*rule)
+     return;
+ 
+   if((*rule)->next)
+     free_rule_list(&((*rule)->next));
+ 
+   if((*rule)->prule)
+     free_rule(&((*rule)->prule));
+ 
+   fs_give((void **)rule);
+ }
+ 
+ void
+ free_parsed_rule_list(rule)
+   PRULELIST_S **rule;
+ {
+   if(!*rule)
+     return;
+ 
+   if((*rule)->next)
+     free_parsed_rule_list(&((*rule)->next));
+ 
+   if((*rule)->rlist)
+     free_rule_list(&((*rule)->rlist));
+ 
+   fs_give((void **)rule);
+ }
+ 
+ void *
+ alloc_mem (amount)
+   size_t amount;
+ {
+    void *genmem;
+    memset(genmem = fs_get(amount), 0, amount);
+    return genmem;
+ }
+ 
+ int
+ isolate_condition (data, cvalue, len)
+   char *data, **cvalue;
+   int  *len;
+ {
+   char *p = data;
+   int done = 0, error = 0, next_condition = 0, l;
+ 
+   if(*p == '"' && p[strlen(p) - 1] == '"'){
+     p[strlen(p) - 1] = '\0';
+     p++;
+   }
+   *cvalue = NULL;
+   while (*p && !done){
+ 	switch (*p){
+ 	   case '_': *cvalue = advance_to_char(p,'}', STRICT, NULL);
+ 		     if(*cvalue){
+ 			strcat(*cvalue,"}");
+ 			p += strlen(*cvalue);
+ 		     }
+ 		     else
+ 			error++;
+ 		     done++;
+ 	   case ' ': p++;
+ 		     break;
+ 	   case '&': if (*(p+1) == '&'){	/* looking for && */
+ 			p += 2;
+ 			next_condition++;
+ 		     }
+ 		     else{
+ 			error++;
+ 			done++;
+ 		     }
+ 		     break;
+ 	   case '=': /* looking for => or -> */
+ 	   case '-': if ((*(p+1) == '>') && (!next_condition)){
+ 		        is_save = (*p == '-');
+ 			p += 2;
+ 		     }
+ 		     else
+ 			error++;
+ 		     done++;
+ 		     break;
+ 	   default : done++;
+ 		     error++;
+ 		     break;
+ 	}
+   }
+   *len = p - data;
+   return error ? -1 : (*cvalue ? 1 : 0);
+ }
+ 
+ TOKEN_VALUE *
+ parse_group_data (data, error)
+   char *data;
+   int *error;
+ {
+   TOKEN_VALUE *rvalue;
+   char *p;
+   int offset, err = 0;
+ 
+   if(error)
+     *error = 0;
+ 
+   if (!data)
+      return (TOKEN_VALUE *) NULL;
+ 
+   rvalue = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
+   if (p = advance_to_char(data,';', STRICT, &offset)){
+       rvalue->testxt = cpystr(p);
+       data += strlen(p) + 1 + offset;
+       rvalue->next   = parse_group_data(data, error);
+   }
+   else if (p = advance_to_char(data,'}', STRICT, NULL))
+       rvalue->testxt = cpystr(p);
+   else if (data && *data == '}')
+       rvalue->testxt = cpystr("");
+   else{
+       err++;
+       free_token_value(&rvalue);
+   }
+   if (error)
+     *error += err;
+   return(rvalue);
+ }
+ 
+ CONDITION_S *
+ fill_condition(data)
+   char *data;
+ {
+   CONDITION_S *condition;
+   int i, done, error = 0;
+   char *group;
+ 
+   for (i = 0, done = 0; !done && (i < NTOKENS); i++)
+       done = strncmp(data,token_rules[i], strlen(token_rules[i])) ? 0 : 1;
+   if (done){
+      condition = (CONDITION_S *) alloc_mem(sizeof(CONDITION_S));
+      condition->tname = cpystr(token_rules[--i]);
+   }
+   else
+      return (CONDITION_S *)NULL;
+ 
+   data += strlen(token_rules[i]);
+   for (; *data && *data == ' '; data++);
+   if (*data){
+      for (i = 0, done = 0; !done && (i < NREL); i++)
+        done = strncmp(data, rel_rules_test[i].value, 2) ? 0 : 1;
+      if (done)
+        condition->ttype = rel_rules_test[--i].ttype;
+      else{
+ 	 free_condition(&condition);
+ 	 return (CONDITION_S *) NULL;
+      }
+   }
+   data += 2;
+   for (; *data && *data == ' '; data++);
+   if (*data++ != '{'){
+      free_condition(&condition);
+      return (CONDITION_S *) NULL;
+   }
+   group = advance_to_char(data,'}', STRICT, &error); 
+   if (group || (!group &&  error < 0)){
+      condition->value = parse_group_data(data, &error);
+      if(group && error)
+ 	free_condition(&condition);
+      if(group)
+         fs_give((void **) &group);
+   }
+   else
+      free_condition(&condition);
+   return condition;
+ }
+ 
+ CONDITION_S *
+ parse_condition (data, eoc)
+   char *data;
+   int  *eoc;	/* end of condition, equal to -1 on error */
+ {
+   CONDITION_S *condition = NULL;
+   char *p = data, *cvalue;
+   int len, error = 0, rv;
+ 
+   if((rv = isolate_condition(data, &cvalue, &len)) > 0){
+     if(condition = fill_condition(cvalue))
+        condition->next = parse_condition(data+len, eoc);
+     else
+        error++;
+   }
+   *eoc += len;
+   if (error)
+     *eoc = -1;
+   return condition;
+ }
+ 
+ RULEACTION_S *
+ parse_action (data, context)
+   char *data;
+   int context;
+ {
+   int i, done;
+   RULEACTION_S *raction = NULL;
+   char *function, *p = data;
+ 
+   if (!p)
+      return (RULEACTION_S *) NULL;
+ 
+   for (; *p && *p == ' '; p++);
+   if (!*p)
+      return (RULEACTION_S *) NULL;
+ 
+   if (is_save){
+      raction = (RULEACTION_S *) alloc_mem(sizeof(RULEACTION_S));
+      raction->function = cpystr("_SAVE_");
+      raction->value    = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
+      raction->context |= FOR_SAVE;
+      raction->exec     = extended_value;
+      raction->value->testxt = cpystr(p);
+      return raction;
+   }
+   for (i = 0, done = 0; !done && (i < NFCN); i++)
+        done = (strstr(p,rule_fcns[i].name) == p);
+   p += done ? strlen(rule_fcns[--i].name) + 1 : 0;
+   if(!*p || (rule_fcns[i].what_for && !(rule_fcns[i].what_for & context)))
+      return (RULEACTION_S *) NULL;
+   if (done){
+      raction = (RULEACTION_S *) alloc_mem(sizeof(RULEACTION_S));
+      raction->function = cpystr(rule_fcns[i].name);
+      raction->context  = rule_fcns[i].what_for;
+      raction->exec     = rule_fcns[i].execute;
+      raction->value    = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
+      raction->value->testxt = advance_to_char(p,'}', STRICT, NULL);
+      if(!raction->value->testxt)
+        free_ruleaction(&raction);
+      return raction;
+   }
+ 
+   done = (((function = strstr(p, "_TRIM_")) != NULL)
+ 	  ? 1 : ((function = strstr(p, "_COPY_")) != NULL)
+ 	  ? 2 : ((function = strstr(p, "_REXTRIM_")) != NULL)
+ 	  ? 3 : ((function = strstr(p, "_REPLACE_")) != NULL)
+ 	  ? 4 : 0);
+ 
+   if(!function)
+      return (RULEACTION_S *) NULL;
+ 
+   *function = '\0';
+    raction = (RULEACTION_S *) alloc_mem(sizeof(RULEACTION_S));
+    raction->token = get_name_token(p);
+   *function = '_';
+    p += strlen(raction->token) + 1;
+    for (; *p && *p == ' '; p++);
+    if (!strncmp(p,":=",2))
+       p += 2;
+    else{
+       free_ruleaction(&raction);
+       return (RULEACTION_S *) NULL;
+    }
+    for (; *p && *p == ' '; p++);
+    if (p != function){
+       free_ruleaction(&raction);
+       return (RULEACTION_S *) NULL;
+    }
+    p += done <= 2 ? 6: 9;
+    if (*p != '{'){
+       free_ruleaction(&raction);
+       return (RULEACTION_S *) NULL;
+    }
+    *p = '\0';
+    for(i = 0; i < NFCN && strcmp(function, rule_fcns[i].name);i++);
+    raction->function   = cpystr(function);
+    raction->is_trim    = strcmp(function,"_TRIM_")    ? 0 : 1;
+    raction->is_rextrim = strcmp(function,"_REXTRIM_") ? 0 : 1;
+    raction->is_replace = strcmp(function,"_REPLACE_") ? 0 : 1;
+    raction->context  = rule_fcns[i].what_for;
+    raction->exec     = rule_fcns[i].execute;
+    *p++ = '{';
+    raction->value = parse_group_data(p, NULL);
+    if(!raction->value->testxt)
+       free_ruleaction(&raction);
+    return raction;
+ }
+ 
+ RULE_S *
+ parse_rule (data, context)
+   char *data;
+   int context;
+ {
+   RULE_S *prule;	/*parsed rule */
+   int len = 0;
+   
+   if (!(prule = (RULE_S *) alloc_mem(sizeof(RULE_S))) ||
+ 	!(prule->condition = parse_condition(data, &len)) ||
+ 	!(prule->action = parse_action(data+len, context)))
+       free_rule(&prule);
+ 
+   return prule;
+ }
+ 
+ RULELIST *
+ get_rule_list(list, context, i)
+   char **list;
+   int context, i;
+ {
+   RULE_S *rule;
+   RULELIST *trulelist = NULL;
+ 
+   if (list[i] && *list[i]){
+      if(rule = parse_rule(list[i], context)){
+ 	trulelist  = (RULELIST *)alloc_mem(sizeof(RULELIST));
+ 	trulelist->prule = rule;
+ 	trulelist->next = get_rule_list(list, context, i+1);
+      }
+      else
+ 	trulelist = get_rule_list(list, context, i+1);
+   }
+   return trulelist;
+ }
+ 
+ PRULELIST_S *
+ add_prule(rule_list, rule)
+   PRULELIST_S *rule_list;
+   PRULELIST_S *rule;
+ {
+    if (!rule_list)
+       rule_list = (PRULELIST_S *) alloc_mem(sizeof(PRULELIST_S));
+ 
+    if(rule_list->next)
+      rule_list->next = add_prule(rule_list->next, rule);
+    else{
+      if (rule_list->rlist)
+ 	rule_list->next = rule;
+      else
+ 	rule_list = rule;
+    }
+    return rule_list;
+ }  
+ 
+ void
+ add_rule(code, context)
+   int code, context;
+ {
+   char **list = ps_global->vars[code].current_val.l;
+   PRULELIST_S *prulelist, *trulelist, *orulelist;
+ 
+   if (list && *list && **list){
+      trulelist = (PRULELIST_S *)alloc_mem(sizeof(PRULELIST_S));
+      trulelist->varnum = code;
+      if (trulelist->rlist = get_rule_list(list, context, 0))
+         ps_global->rule_list = add_prule(ps_global->rule_list, trulelist);
+      else
+ 	free_parsed_rule_list(&trulelist);
+   }
+ }
+ 
+ void
+ create_rule_list(void)
+ {
+   add_rule(V_THREAD_DISP_STYLE_RULES, FOR_THREAD);
+   add_rule(V_THREAD_INDEX_STYLE_RULES, FOR_THREAD);
+   add_rule(V_COMPOSE_RULES, FOR_COMPOSE);
+   add_rule(V_FORWARD_RULES, FOR_COMPOSE);
+   add_rule(V_INDEX_RULES, FOR_INDEX);
+   add_rule(V_KEY_RULES, FOR_KEY);
+   add_rule(V_REPLACE_RULES, FOR_REPLACE);
+   add_rule(V_REPLY_INDENT_RULES, FOR_COMPOSE);
+   add_rule(V_REPLY_LEADIN_RULES, FOR_REPLY_INTRO);
+   add_rule(V_RESUB_RULES, FOR_RESUB|FOR_TRIM);
+   add_rule(V_SAVE_RULES, FOR_SAVE);
+   add_rule(V_SMTP_RULES, FOR_COMPOSE);
+   add_rule(V_SORT_RULES, FOR_SORT);
+   add_rule(V_STARTUP_RULES, FOR_STARTUP);
+ }
+ 
+ int
+ condition_contains_token(condition, token)
+   CONDITION_S *condition;
+   char *token;
+ {
+   if (!condition)
+     return 0;
+ 
+   if (!strcmp(condition->tname, token))
+      return 1;
+   else
+      return condition_contains_token(condition->next, token);
+ }
+ 
+ RULELIST *
+ get_rulelist_from_code(code, list)
+   int code;
+   PRULELIST_S *list;
+ {
+   if (!list)
+      return (RULELIST *) NULL;
+ 
+   if(list->varnum == code)
+      return list->rlist;
+   else
+      return get_rulelist_from_code(code, list->next);
+ }   
+ 
+ char *
+ test_rule(rlist, ctxt, env, n)
+   RULELIST *rlist;
+   int ctxt, *n;
+   ENVELOPE *env;
+ {
+   char *result;
+ 
+   if(!rlist)
+      return NULL;
+ 
+   if (result = process_rule(rlist->prule, ctxt, env))
+       return result;
+   else{
+        (*n)++;
+        return test_rule(rlist->next, ctxt, env, n);
+   } 
+ }
+ 
+ RULE_S *
+ get_rule (rule, n)
+   RULELIST *rule;
+   int n;
+ {
+   if (!rule)
+      return (RULE_S *) NULL;
+ 
+   return n ? get_rule(rule->next, n-1) : rule->prule;
+ }
+ 
+ /* get_result_rule:
+  * Parameters: list: the list of rules to be passed to the function to check
+  *             rule_context: context of the rule
+  *             env : envelope used to check the rule, if needed.
+  *
+  * Returns: The value of the first rule that is satisfied in the list, or
+  *          NULL if not. This function should be called in the following 
+  *          way (notice that memory is freed by caller).
+  *
+  * You should use this function to obtain the result of a rule. You can
+  * also call directly "process_rule", but I advice to use this function if
+  * there's no difference on which function to call.
+ 
+    RULE_RESULT *rule;
+ 
+    rule = (RULE_RESULT *) 
+            get_result_rule(V_SOME_RULE, context, envelope);
+ 
+    if (rule){ 
+        assign the value of rule->result;
+        if (rule->result)
+           fs_give((void **)&rule->result);
+        fs_give((void **)&rule);
+    }
+  */
+ 
+ RULE_RESULT *
+ get_result_rule(code, rule_context, env)
+  int code, rule_context;
+  ENVELOPE *env;
+ {
+     char  *rule_result;
+     RULE_RESULT *rule = NULL;
+     RULELIST *rlist;
+     int n = 0;
+ 
+     if(!(rule_context & FOR_RULE))
+       rule_context |= FOR_RULE;
+     rlist = get_rulelist_from_code(code, ps_global->rule_list);
+     if (rlist){
+        rule_result = test_rule(rlist, rule_context, env, &n);
+        if (rule_result && *rule_result){
+           rule = (RULE_RESULT *) fs_get (sizeof(RULE_RESULT));
+           rule->result = rule_result;
+           rule->number = n;
+        }
+     }
+     return rule;
+ }
+ 
+ char *get_rule_result(rule_context, newfolder, code)
+ int rule_context;
+ char *newfolder;
+ int code;
+ {   char        *rule_result = NULL;
+     ENVELOPE    *news_envelope;
+     RULE_RESULT *rule;
+ 
+     if (IS_NEWS(ps_global->mail_stream)){
+        news_envelope = mail_newenvelope();
+        news_envelope->newsgroups = cpystr(newfolder);
+     }
+     else
+        news_envelope = NULL;
+ 
+     rule = get_result_rule(code, rule_context, news_envelope);
+ 
+     if (news_envelope)
+         mail_free_envelope (&news_envelope);
+ 
+     if (rule){
+         rule_result = cpystr(rule->result);
+         if (rule->result)
+           fs_give((void **)&rule->result);
+         fs_give((void **)&rule);
+     }
+ 
+     return rule_result;
+ }
+ 
+ /* process_rule:
+    Parameters: rule_data, is a rule. It's obtained as
+                 rule_data = ps_global->VAR_SOME_RULE[n], for
+                 some integer n
+                 rule_context: context of the rule, and
+                 env: An envelope if needed.
+ 
+    Returns   : The value of the processed rule_data if the processing was 
+                successful and matches context and possibly the envelope, or
+                NULL if there's no match
+  */
+ 
+ char *
+ process_rule (prule, rule_context, env)
+  RULE_S *prule;
+  int  rule_context;
+  ENVELOPE *env;
+ {
+     char *result = NULL;
+     int rv;
+     CONDITION_S *condition;
+ 
+    if(!prule)
+      return NULL;
+ 
+    if(!(rule_context & FOR_RULE))
+       rule_context |= FOR_RULE;
+ 
+    for(condition = prule->condition; 
+ 		   condition && 
+ 		   (rv = test_condition(condition, rule_context, env));
+ 		   condition = condition->next);
+ 
+    if(rv && !condition)
+       result = (prule->action->exec)(prule->action, rule_context, env);
+ 
+    return result;
+ }
+ 
+ TOKEN_VALUE *
+ copy_parsed_value(value, ctxt, env)
+    TOKEN_VALUE *value;
+    int ctxt;
+    ENVELOPE *env;
+ {
+    TOKEN_VALUE *tval = NULL;
+ 
+    if(!value)
+       return NULL;
+ 
+    if(value->testxt){
+      tval = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
+      tval->testxt = detoken_src(value->testxt, ctxt, env, NULL, NULL, NULL);
+    }
+    if(value->next)
+      tval->next = copy_parsed_value(value->next, ctxt, env);
+ 
+    return tval;
+ }
+ 
+ int
+ test_condition(condition, rule_context, env)
+ CONDITION_S *condition;
+ int rule_context;
+ ENVELOPE *env;
+ {
+    int next_step;
+    TOKEN_VALUE *group;
+ 
+    group = copy_parsed_value(condition->value, rule_context, env);
+    next_step = (*rel_rules_test[condition->ttype].execute)(condition, group, env, rule_context);
+    free_token_value(&group);
+    return next_step;
+ }
+ 
+ /* returns the name of the token it found or NULL if there is no token, the
+  * real value of the token is obtained by calling the detoken_src function.
+  */ 
+ 
+ char *
+ get_name_token (condition)
+ char *condition;
+ {
+   char *p = NULL, *q, *s;
+ 
+     if ((q = strchr(condition,'_')) && (s = strchr(q+1,'_'))){
+ 	char c = *++s;
+ 	*s = '\0';
+ 	 p = cpystr(q);
+ 	*s = c;
+     }
+     return p;
+ }
+ 
+ /* This function tests if a string contained in the variable "group" is
+  * in the "condition"
+  */
+ int test_in (condition, group, env, context)
+ TOKEN_VALUE *group;
+ CONDITION_S *condition;
+ ENVELOPE *env;
+ int context;
+ {
+  int rv = 0;
+  char *test;
+  TOKEN_VALUE *test_group = group;
+ 
+  test = detoken_src(condition->tname, context, env, NULL, NULL, NULL);
+  if (test){
+     while (rv == 0 && test_group){
+        if(!*test || strstr(test_group->testxt, test))
+ 	  rv++;
+        else
+ 	  test_group = test_group->next;
+     }
+  }
+  return rv;
+ }
+ 
+ int test_ni (condition, group, env, context)
+ TOKEN_VALUE *group;
+ CONDITION_S *condition;
+ ENVELOPE *env;
+ int context;
+ {
+  int rv = 0;
+  char *test;
+  TOKEN_VALUE *test_group = group;
+ 
+  test = detoken_src(condition->tname, context, env, NULL, NULL, NULL);
+  if (test){
+     if(!test_group)
+       rv++;
+     while (rv == 0 && test_group){
+        if(!*test_group->testxt || strstr(test, test_group->testxt))
+ 	  rv++;
+        else
+ 	  test_group = test_group->next;
+     }
+  }
+  return rv;
+ }
+ 
+ int test_not_in (condition, group, env, context)
+ TOKEN_VALUE *group;
+ CONDITION_S *condition;
+ ENVELOPE *env;
+ int context;
+ {
+  return !test_in(condition, group, env, context);
+ }
+ 
+ int test_not_ni (condition, group, env, context)
+ TOKEN_VALUE *group;
+ CONDITION_S *condition;
+ ENVELOPE *env;
+ int context;
+ {
+  return !test_ni(condition, group, env, context);
+ }
+ 
+ int test_eq (condition, group, env, context)
+ CONDITION_S *condition;
+ TOKEN_VALUE *group;
+ ENVELOPE *env;
+ int context;
+ {
+  int rv = 0;
+  char *test;
+  TOKEN_VALUE *test_group = group;
+ 
+  test = detoken_src(condition->tname, context, env, NULL, NULL, NULL);
+  if (test){
+     while (rv == 0 && test_group){
+        if((!*test && !*test_group->testxt) || !strcmp(test_group->testxt, test))
+ 	  rv++;
+        else
+ 	  test_group = test_group->next;
+     }
+  }
+  return rv;
+ }
+ 
+ int test_not_eq (condition, group, env, context)
+ CONDITION_S *condition;
+ TOKEN_VALUE *group;
+ ENVELOPE *env;
+ int context;
+ {
+  return !test_eq(condition, group, env, context);
+ }
+ 
+ char *
+ do_trim (test, tval)
+   char *test;
+   TOKEN_VALUE *tval;
+ {
+    char *begin_text;
+    int offset = 0;
+ 
+    if (!tval)
+       return test;
+ 
+    while(begin_text = strstr(test+offset,tval->testxt)){
+       strcpy(begin_text, begin_text+strlen(tval->testxt));
+       offset = begin_text - test;
+    }
+ 
+    return do_trim(test, tval->next);
+ }
+ 
+ char *
+ trim (action, context, env)
+  RULEACTION_S *action;
+  int context;
+  ENVELOPE *env;
+ {
+  char *begin_text, *test;
+  RULEACTION_S *taction = action;
+  int offset;
+ 
+  if (taction->context & context){
+     test = detoken_src(taction->token, context, env, NULL, NULL, NULL);
+     if (test)
+        test = do_trim(test, taction->value);
+     return test;
+  }
+  return NULL;
+ }
+ 
+ 
+ char *
+ do_rextrim (test, tval)
+   char *test;
+   TOKEN_VALUE *tval;
+ {
+    char *begin_text, *trim_text;
+    int offset = 0;
+ 
+    if (!tval)
+       return test;
+ 
+    trim_text = expand(test, tval->testxt);
+    while(trim_text && (begin_text = strstr(test+offset,trim_text))){
+       strcpy(begin_text, begin_text+strlen(trim_text));
+       offset = begin_text - test;
+    }
+ 
+    return do_rextrim(test, tval->next);
+ }
+ 
+ char *
+ rextrim (action, context, env)
+  RULEACTION_S *action;
+  int context;
+  ENVELOPE *env;
+ {
+  char *begin_text, *trim_text, *test;
+  RULEACTION_S *taction = action;
+  TOKEN_VALUE **token = NULL;
+  int offset;
+ 
+  if (taction->context & context){
+     test = detoken_src(taction->token, context, env, NULL, NULL, NULL);
+     if (test){
+ 	test = do_rextrim(test, taction->value);
+     }
+     return test;
+   }
+   else
+      return NULL;
+ }
+ 
+ char *
+ raw_value (action, context,env)
+ RULEACTION_S *action;
+ int context;
+ ENVELOPE *env;
+ {
+ return (action->context & context) ? cpystr(action->value->testxt) : NULL;
+ }
+ 
+ char *
+ extended_value (action, ctxt,env)
+ RULEACTION_S *action;
+ int ctxt;
+ ENVELOPE *env;
+ {
+ return (action->context & ctxt) 
+ 	? detoken_src(action->value->testxt, ctxt, env, NULL, NULL, NULL)
+ 	: NULL;
+ }
+ 
+ /* advances given_string until it finds given_char  */
+ char *
+ advance_to_char(given_string,given_char, flag, error) 
+  char *given_string;                          
+  char given_char;
+  int flag;
+  int *error;
+ {
+    char *b, *s, c;
+    int i, err  = 0, quoted ;
+ 
+    if (error) 
+       *error = 0;
+ 
+    if (!given_string || !*given_string)
+        return NULL;
+ 
+    b = s = cpystr(given_string);
+    for(i = 0, quoted = 0, c = *s; c ; c = *++s){
+       if(c == '\\'){
+ 	 quoted++;
+ 	 continue;
+       }
+       if(quoted){
+ 	quoted = 0;
+ 	if (c == given_char){
+ 	  err += flag & STRICT ? 0 : 1;
+ 	  err++;
+ 	  break;
+ 	}
+ 	b[i++] = '\\';
+       }
+       if(c == given_char){
+ 	 err += flag & STRICT ? 0 : 1;
+ 	 break;
+       }
+       b[i++] = c;
+    }
+    b[i] = '\0';
+    if (b && (strlen(b) == strlen(given_string)) && (flag & STRICT))
+       return NULL;   /* character not found */
+ 
+    if(b && !*b){
+      fs_give((void **)&b);
+      err = -1;
+    }
+ 
+    if (error)
+       *error = err;
+ 
+    return b;
+ }
+ 
+ /* Regular Expressions Support */
+ 
+ char *
+ expand (string, pattern)
+ char *string;
+ char *pattern;
+ {
+  char tmp[1000];
+  int error, i = 0;
+  char *new_start, c;
+  char *ret_string = NULL;
+  regex_t preg;
+  regmatch_t pmatch;
+  
+   if (error = regcomp(&preg, pattern, REG_EXTENDED)){
+      regerror(error, &preg, tmp, 1000);
+      return NULL;
+   }
+ 
+   if(((error = regexec(&preg, string, 1, &pmatch, 0)) != REG_NOMATCH)&& !error){
+       c = string[pmatch.rm_eo];
+       string[pmatch.rm_eo] = '\0';
+       ret_string = cpystr(string+pmatch.rm_so);
+       string[pmatch.rm_eo] = c;
+   }
+   return ret_string;
+ }
diff -rc pine4.64/pine/rules.h pine4.64.rules/pine/rules.h
*** pine4.64/pine/rules.h	Tue Oct 17 07:59:14 2006
--- pine4.64.rules/pine/rules.h	Sun Oct 15 08:08:59 2006
***************
*** 0 ****
--- 1,225 ----
+ #include "headers.h"
+ #ifndef _REGEX_H_
+ #include <regex.h>
+ #endif
+ 
+ int is_save;	/* this rule has the form condition -> folder */
+ typedef struct {
+ 	char	*value;
+ 	int	type;
+ } RULE_ACTION;
+ 
+ 
+ RULE_RESULT *get_result_rule PROTO ((int, int, ENVELOPE *));
+ char	*test_rule	PROTO ((RULELIST *, int, ENVELOPE *, int *));
+ char	*process_rule	PROTO ((RULE_S *, int, ENVELOPE *));
+ int	test_condition	PROTO ((CONDITION_S *, int, ENVELOPE *));
+ int	test_in		PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ int	test_ni		PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ int	test_not_in	PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ int	test_not_ni	PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ int	test_eq		PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ int	test_not_eq	PROTO ((CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int));
+ char	*trim		PROTO ((RULEACTION_S *, int, ENVELOPE *));
+ char	*rextrim	PROTO ((RULEACTION_S *, int, ENVELOPE *));
+ char	*raw_value	PROTO ((RULEACTION_S *, int, ENVELOPE *));
+ char	*extended_value	PROTO ((RULEACTION_S *, int, ENVELOPE *));
+ char	*expand		PROTO((char *, char *));
+ char	*get_name_token PROTO((char *));
+ char	*advance_to_char PROTO ((char *, char, int, int *));
+ 
+ /* Separators:
+  *
+  * A separator is a string that separates the rule condition with the rule
+  * action. Below is the list of separators
+  *
+  */
+ 
+ #define  SAVE_TO_SEP  "->"
+ #define  APPLY_SEP    "=>"
+ 
+ /*------- Definitions of tokens -------*/
+ /*------ Keep the list alphabetically sorted, thanks -------*/
+ 
+ #define ADDR_TOKEN	"_ADDRESS_"
+ #define ADDCC_TOKEN	"_ADDRESSCC_"
+ #define ADDRECIP_TOKEN	"_ADDRESSRECIPS_"
+ #define ADDTO_TOKEN	"_ADDRESSTO_"
+ #define BCC_TOKEN	"_BCC_"
+ #define CC_TOKEN	"_CC_"
+ #define COLLECT_TOKEN	"_COLLECTION_"
+ #define FLAG_TOKEN	"_FLAG_"
+ #define FOLDER_TOKEN	"_FOLDER_"
+ #define FADDRESS_TOKEN	"_FORWARDADDRESS_"
+ #define FFROM_TOKEN	"_FORWARDFROM_"
+ #define FROM_TOKEN	"_FROM_"
+ #define KEY_TOKEN	"_PKEY_"
+ #define LCC_TOKEN	"_LCC_"
+ #define NICK_TOKEN	"_NICK_"
+ #define PROCID_TOKEN	"_PROCID_"
+ #define ROLE_TOKEN	"_ROLE_"
+ #define SCREEN_TOKEN	"_SCREEN_"
+ #define SEND_TOKEN	"_SENDER_"
+ #define SUBJ_TOKEN	"_SUBJECT_"
+ #define THDDSPSTY_TOKEN	"_THREADSTYLE_"
+ #define THDNDXSTY_TOKEN	"_THREADINDEX_"
+ #define TO_TOKEN	"_TO_"
+ 
+ /* Mail related tokens 
+  *
+  * The following is an array with the list of tokens.
+  */
+ 
+ char* token_rules[] = {
+    FROM_TOKEN,
+    NICK_TOKEN,
+    ROLE_TOKEN,
+    FOLDER_TOKEN,
+    SUBJ_TOKEN,
+    PROCID_TOKEN,
+    THDDSPSTY_TOKEN,
+    THDNDXSTY_TOKEN,
+    FLAG_TOKEN,
+    COLLECT_TOKEN,
+    THDDSPSTY_TOKEN,
+    ADDR_TOKEN,
+    TO_TOKEN,
+    ADDTO_TOKEN,
+    ADDCC_TOKEN,
+    ADDRECIP_TOKEN,
+    SCREEN_TOKEN,
+    KEY_TOKEN,
+    SEND_TOKEN,
+    CC_TOKEN,
+    LCC_TOKEN,
+    BCC_TOKEN,
+    FFROM_TOKEN,
+    FADDRESS_TOKEN,
+    NULL
+ };
+ 
+ #define NTOKENS  (sizeof(token_rules)/sizeof(token_rules[0]) - 1)
+ 
+ /*------ Definitions of relational operands -------------*/
+ 
+ typedef struct {
+         char       *value;
+ 	TestType    ttype;
+         int        (*execute)();
+ } REL_TOKEN;
+ 
+ /* Relational Operands */
+ #define AND_REL     "&&"        /* For putting more than one condition  */
+ #define IN_REL      "<<"        /* For belonging relation */
+ #define NI_REL      ">>"        /* For contain relation   */
+ #define NOT_IN_REL  "!<"        /* Negation of IN_REL   */
+ #define NOT_NI_REL  "!>"        /* Negation of NI_REL   */
+ #define EQ_REL      "=="        /* Test of equality     */
+ #define NOT_EQ_REL  "!="        /* Test of inequality   */
+ #define OPEN_SET    "{"         /* Braces to open a set */
+ #define CLOSE_SET   "}"         /* Braces to close a set*/
+ 
+ REL_TOKEN rel_rules_test[] = {
+    {EQ_REL,	Equal,		test_eq},
+    {IN_REL,	Subset,		test_in},
+    {NI_REL,	Includes,	test_ni},
+    {NOT_EQ_REL, NotEqual,	test_not_eq},
+    {NOT_IN_REL, NotSubset,	test_not_in},
+    {NOT_NI_REL, NotIncludes,	test_not_ni},
+    {NULL,	EndTypes,	NULL}
+ };
+ 
+ #define NREL  (sizeof(rel_rules_test)/sizeof(rel_rules_test[0]) - 1)
+ 
+ /*--- Context in which these variables can be used ---*/
+ 
+ typedef struct use_context {
+     char        *name;
+     int          what_for;
+ } USE_IN_CONTEXT;
+ 
+ 
+ static USE_IN_CONTEXT tokens_use[] = {
+     {NICK_TOKEN,	FOR_SAVE},
+     {FROM_TOKEN,	FOR_SAVE},
+     {ROLE_TOKEN,	FOR_COMPOSE},
+     {FOLDER_TOKEN,	FOR_SAVE|FOR_FOLDER|FOR_THREAD},
+     {SUBJ_TOKEN,	FOR_SAVE|FOR_FOLDER},
+     {FLAG_TOKEN,	FOR_SAVE|FOR_FLAG},
+     {COLLECT_TOKEN,	FOR_SAVE|FOR_COMPOSE|FOR_FOLDER|FOR_THREAD},
+     {THDDSPSTY_TOKEN,	FOR_THREAD},
+     {THDNDXSTY_TOKEN,	FOR_THREAD},
+     {ADDR_TOKEN,	FOR_SAVE|FOR_FOLDER},
+     {TO_TOKEN,		FOR_SAVE},
+     {ADDTO_TOKEN,	FOR_SAVE|FOR_COMPOSE},
+     {ADDCC_TOKEN,	FOR_SAVE|FOR_COMPOSE},
+     {ADDRECIP_TOKEN,	FOR_SAVE|FOR_COMPOSE},
+     {SCREEN_TOKEN,	FOR_KEY},
+     {KEY_TOKEN,		FOR_KEY},
+     {SEND_TOKEN,	FOR_SAVE},
+     {CC_TOKEN,		FOR_SAVE},
+     {BCC_TOKEN,		FOR_COMPOSE},
+     {LCC_TOKEN,		FOR_COMPOSE},
+     {FFROM_TOKEN,	FOR_COMPOSE},
+     {FADDRESS_TOKEN,	FOR_COMPOSE},
+     {NULL,		FOR_NOTHING}
+ };
+ 
+ 
+ typedef struct {
+         char         *name;
+         char*        (*execute)();
+         int          what_for;
+ } RULE_FCN;
+ 
+ #define COMMAND_FCN	"_COMMAND_"
+ #define COPY_FCN	"_COPY_"
+ #define INDEX_FCN       "_INDEX_"
+ #define REPLACE_FCN     "_REPLACE_"
+ #define REPLYSTR_FCN    "_RESTR_"
+ #define REPLY_FCN       "_REPLY_"
+ #define RESUB_FCN       "_RESUB_"
+ #define REXTRIM_FCN	"_REXTRIM_"
+ #define SAVE_FCN        "_SAVE_"
+ #define SIGNATURE_FCN   "_SIGNATURE_"
+ #define SMTP_FCN        "_SMTP_"
+ #define SORT_FCN        "_SORT_"
+ #define STARTUP_FCN     "_STARTUP_"
+ #define THRDSTYLE_FCN   "_THREADSTYLE_"
+ #define THRDINDEX_FCN   "_THREADINDEX_"
+ #define TRIM_FCN        "_TRIM_"
+ 
+ 
+ RULE_FCN rule_fcns[] = {
+ {COPY_FCN,	extended_value, FOR_SAVE | FOR_COMPOSE},
+ {SAVE_FCN,      extended_value, FOR_SAVE},
+ {REPLY_FCN,     extended_value, FOR_REPLY_INTRO},
+ {TRIM_FCN,      trim,		FOR_TRIM | FOR_RESUB},
+ {REPLACE_FCN,   extended_value,	FOR_REPLACE},
+ {SORT_FCN,      raw_value,	FOR_SORT},
+ {INDEX_FCN,     raw_value,	FOR_INDEX},
+ {COMMAND_FCN,	raw_value,	FOR_KEY},
+ {REPLYSTR_FCN,  raw_value,	FOR_COMPOSE},
+ {SIGNATURE_FCN, raw_value,	FOR_COMPOSE},
+ {RESUB_FCN,     extended_value,	FOR_RESUB},
+ {STARTUP_FCN,   raw_value,	FOR_STARTUP},
+ {REXTRIM_FCN,   rextrim,	FOR_TRIM | FOR_RESUB},
+ {THRDSTYLE_FCN, raw_value,	FOR_THREAD},
+ {THRDINDEX_FCN, raw_value,	FOR_THREAD},
+ {SMTP_FCN,      raw_value,	FOR_COMPOSE},
+ {NULL,		0,		FOR_NOTHING}
+ };
+ 
+ #define NFCN    (sizeof(rule_fcns)/sizeof(rule_fcns[0]) - 1)
+ 
+ #define STRICT  0x1
+ #define RELAXED 0x2
+ 
+ char *subj_fcn[] = {SUBJ_TOKEN, REPLACE_FCN, TRIM_FCN, REXTRIM_FCN};
+ char *from_fcn[] = {FROM_TOKEN, REPLACE_FCN, TRIM_FCN, REXTRIM_FCN};
+ char *adto_fcn[] = {ADDTO_TOKEN, NULL, NULL, NULL};
+ 
+ char **fcns_for_index[] = {subj_fcn, from_fcn};
+ 
+ #define NFCNFI    (sizeof(fcns_for_index)/sizeof(fcns_for_index[0])) /*for idx*/
+ #define NFPT	  (sizeof(fcns_for_index[0])) /* functions pert token */
diff -rc pine4.64/pine/send.c pine4.64.rules/pine/send.c
*** pine4.64/pine/send.c	Mon Sep 12 15:04:25 2005
--- pine4.64.rules/pine/send.c	Sat Oct 14 08:55:30 2006
***************
*** 377,382 ****
--- 377,387 ----
  	role->nick = cpystr("Default Role");
      }
  
+     if (ps_global->role)
+        fs_give((void **)&ps_global->role);  
+ 
+     ps_global->role = cpystr(role->nick);
+ 
      pine_state->redrawer = NULL;
      compose_mail(NULL, NULL, role, NULL, NULL);
      free_action(&role);
***************
*** 581,588 ****
  	      }
  	      ps_global->next_screen = prev_screen;
  	      ps_global->redrawer = redraw;
! 	      if(role)
  		role = combine_inherited_role(role);
  	    }
  	    break;
  	  case 'f':
--- 586,597 ----
  	      }
  	      ps_global->next_screen = prev_screen;
  	      ps_global->redrawer = redraw;
! 	      if (ps_global->role)
! 		  fs_give((void **)&ps_global->role);  
! 	      if(role){
  		role = combine_inherited_role(role);
+ 		ps_global->role = cpystr(role->nick);
+ 	      }
  	    }
  	    break;
  	  case 'f':
***************
*** 894,902 ****
  	    }
  	}
  
! 	if(role)
  	  q_status_message1(SM_ORDER, 3, 4, "Composing using role \"%.200s\"",
  			    role->nick);
  
  	/*
  	 * The type of storage object allocated below is vitally
--- 903,917 ----
  	    }
  	}
  
!  	if (ps_global->role)
!  	    fs_give((void **)&ps_global->role);  
! 
! 
! 	if(role){
  	  q_status_message1(SM_ORDER, 3, 4, "Composing using role \"%.200s\"",
  			    role->nick);
+  	  ps_global->role = cpystr(role->nick);
+  	}
  
  	/*
  	 * The type of storage object allocated below is vitally
***************
*** 3771,3776 ****
--- 3786,3811 ----
  		    removing_trailing_white_space(pf->textbuf);
  		    (void)removing_double_quotes(pf->textbuf);
  		    build_address(pf->textbuf, &addr, NULL, NULL, NULL);
+ 		    if (!strncmp(pf->name,"Lcc",3) && addr && *addr){
+ 			RULE_RESULT *rule;
+ 
+   			outgoing->date = cpystr(addr);
+ 			ps_global->procid = cpystr("fwd-lcc");
+ 			rule = get_result_rule(V_FORWARD_RULES,
+ 			           FOR_COMPOSE|FOR_TRIM, outgoing);
+ 			if (rule){
+ 			    addr = cpystr(rule->result);
+ 			    removing_trailing_white_space(addr);
+ 			    (void)removing_extra_stuff(addr);
+ 			    if (rule->result)
+ 				fs_give((void **)&rule->result);
+ 				fs_give((void **)&rule);
+ 			}
+ 			fs_give((void **)&ps_global->procid);
+ 			if (outgoing->date)
+ 			    fs_give((void **)&outgoing->date);
+ 		    }   
+ 
  		    rfc822_parse_adrlist(pf->addr, addr,
  					 ps_global->maildomain);
  		    fs_give((void **)&addr);
***************
*** 6973,6981 ****
      char         error_buf[200], *error_mess = NULL, *postcmd;
      ADDRESS     *a;
      ENVELOPE	*fake_env = NULL;
!     int          addr_error_count, we_cancel = 0;
      long	 smtp_opts = 0L;
!     char	*verbose_file = NULL;
      BODY	*bp = NULL;
      PINEFIELD	*pf;
  
--- 7008,7016 ----
      char         error_buf[200], *error_mess = NULL, *postcmd;
      ADDRESS     *a;
      ENVELOPE	*fake_env = NULL;
!     int          addr_error_count, we_cancel = 0, choice, num_rules = 0, added_rules = -1;
      long	 smtp_opts = 0L;
!     char	*verbose_file = NULL, **smtp_list;
      BODY	*bp = NULL;
      PINEFIELD	*pf;
  
***************
*** 7103,7121 ****
       * was either none specified or we decided not to use it.  So,
       * if there's an smtp-server defined anywhere, 
       */
!     if(alt_smtp_servers && alt_smtp_servers[0] && alt_smtp_servers[0][0]){
! 	/*---------- SMTP ----------*/
! 	dprint(4, (debugfile, "call_mailer: via TCP (%s)\n",
! 		alt_smtp_servers[0]));
! 	TIME_STAMP("smtp-open start (tcp)", 1);
! 	sending_stream = smtp_open(alt_smtp_servers, smtp_opts);
      }
!     else if(ps_global->VAR_SMTP_SERVER && ps_global->VAR_SMTP_SERVER[0]
! 	    && ps_global->VAR_SMTP_SERVER[0][0]){
  	/*---------- SMTP ----------*/
! 	dprint(4, (debugfile, "call_mailer: via TCP\n"));
  	TIME_STAMP("smtp-open start (tcp)", 1);
! 	sending_stream = smtp_open(ps_global->VAR_SMTP_SERVER, smtp_opts);
      }
      else if(postcmd = smtp_command(ps_global->c_client_error)){
  	char *cmdlist[2];
--- 7138,7186 ----
       * was either none specified or we decided not to use it.  So,
       * if there's an smtp-server defined anywhere, 
       */
! 
!      /* First we check for rules and make a list using the rules */
!     if(ps_global->VAR_SMTP_RULES && ps_global->VAR_SMTP_RULES[0]
!         && ps_global->VAR_SMTP_RULES[0][0])
!         while (ps_global->VAR_SMTP_RULES[num_rules]) num_rules++;
! 
!     if(num_rules){
!         int i, j;
!      
!         added_rules = 0;
!         smtp_list = (char **) fs_get ((num_rules + 1)*sizeof(char*));
!         for (i = 0, j = 0; i < num_rules; i++){
! 	   RULELIST *rule = get_rulelist_from_code(V_SMTP_RULES, 
! 							ps_global->rule_list);
! 	   RULE_S *prule = get_rule(rule, i);
! 	   if(prule){
! 	      char *rule_result = process_rule(prule, FOR_COMPOSE, header->env);
! 	      if(rule_result && *rule_result){
! 		smtp_list[j++] = cpystr(rule_result);
! 		added_rules++;
! 	      }
! 	   }
!         }
      }
! 
!     if (added_rules < 0){
!         smtp_list = (char **) fs_get (sizeof(char*));
!         added_rules = 0;
!     }
!     smtp_list[added_rules] = NULL;
! 
!     choice = smtp_list && smtp_list[0] && smtp_list[0][0] ? 3 :
! 	     (alt_smtp_servers && alt_smtp_servers[0] && alt_smtp_servers[0][0] ? 2 :
! 	     (ps_global->VAR_SMTP_SERVER && ps_global->VAR_SMTP_SERVER[0] && ps_global->VAR_SMTP_SERVER[0][0] ? 1 : -1));
! 
!     if(choice > 0){
  	/*---------- SMTP ----------*/
! 	dprint(4, (debugfile, "call_mailer: via TCP (%s)\n",
! 		smtp_list[0]));
  	TIME_STAMP("smtp-open start (tcp)", 1);
! 	sending_stream = smtp_open(choice == 3 ? smtp_list 
! 					: (choice == 2 ? alt_smtp_servers 
! 					: ps_global->VAR_SMTP_SERVER), smtp_opts);
      }
      else if(postcmd = smtp_command(ps_global->c_client_error)){
  	char *cmdlist[2];
diff -rc pine4.64/pine/strings.c pine4.64.rules/pine/strings.c
*** pine4.64/pine/strings.c	Mon Aug 29 17:08:19 2005
--- pine4.64.rules/pine/strings.c	Sat Oct 14 08:55:30 2006
***************
*** 11480,11482 ****
--- 11480,11514 ----
  
      return(idata);
  }
+ 
+ 
+ void
+ removing_extra_stuff(string)
+     char *string;
+ {
+     char *p = NULL;
+     int change = 0, length = 0;
+ 
+ 
+     if(!string)
+       return;
+ 
+     for(; *string; string++, length++)
+       p = ((unsigned char)*string != ',') ? NULL : (!p) ? string : p;
+ 
+     if(p)
+       *p = '\0';
+ 
+     string -= length;
+         for (; *string; string++){
+            if (change){
+               *string = ' ';
+               change = 0;
+            }
+            if ((((unsigned char)*string == ' ') ||
+                 ((unsigned char)*string == ',')) &&
+                 ((unsigned char)*(string + 1) == ','))
+             change++;
+         }
+ }
+ 
