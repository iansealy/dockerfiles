diff -rc pine4.64/pine/folder.c pine4.64.incoming/pine/folder.c
*** pine4.64/pine/folder.c	Mon Sep 12 15:04:25 2005
--- pine4.64.incoming/pine/folder.c	Fri Nov  3 22:35:21 2006
***************
*** 94,100 ****
  #define	FLW_SLCT	0x02
  #define	FLW_LIST	0x04
  
! 
  
  
  /*----------------------------------------------------------------------
--- 94,100 ----
  #define	FLW_SLCT	0x02
  #define	FLW_LIST	0x04
  
! static int max_slot_size = 0;
  
  
  /*----------------------------------------------------------------------
***************
*** 224,229 ****
--- 224,231 ----
  				   gf_io_t, HANDLE_S **, int));
  int	   folder_list_write_folder PROTO((gf_io_t, CONTEXT_S *,
  					   int, char *, int));
+ int	   folder_list_write_count PROTO((FOLDER_S *, CONTEXT_S *, gf_io_t, 
+ 					   int, int));
  int	   folder_list_write_prefix PROTO((FOLDER_S *, int, gf_io_t));
  int	   folder_list_ith PROTO((int, CONTEXT_S *));
  char	  *folder_list_center_space PROTO((char *, int));
***************
*** 469,475 ****
  
  	HELP_MENU,
  	OTHER_MENU,
! 	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
--- 471,477 ----
  
  	HELP_MENU,
  	OTHER_MENU,
!         {"^H","ChkIncFld",{MC_FORCECHECK,1,ctrl('H')}, KS_NONE},
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
***************
*** 1708,1713 ****
--- 1710,1716 ----
      gf_io_t	pc;
  
      dprint(1, (debugfile, "\n\n    ---- FOLDER LISTER ----\n"));
+     ps->in_fld_list = 1;
  
      memset(&folder_proc_data, 0, sizeof(FPROC_S));
      folder_proc_data.fs = fs;
***************
*** 1842,1847 ****
--- 1845,1851 ----
  	  *fs->cache_streamp = NULL;
      }
  
+     ps->in_fld_list = 0;
      return(folder_proc_data.rv);
  }
  
***************
*** 1944,1949 ****
--- 1948,1956 ----
  		gf_puts("\n", pc);
  	    }
  
+ 	    if(!selected_folders(c_list) && (c_list->use & CNTXT_ZOOM))
+ 		c_list->use &= ~CNTXT_ZOOM;
+ 
  	    if(c_list->use & CNTXT_ZOOM){
  		sprintf(tmp_20k_buf, "[ ZOOMED on %d (of %d) %ss ]",
  			selected_folders(c_list),
***************
*** 1955,1960 ****
--- 1962,1979 ----
  		gf_puts("\n", pc);
  	    }
  
+ 	    if (c_list->use & CNTXT_INCMNG &&
+ 		F_ON(F_ENABLE_INCOMING_CHECK,ps_global) &&
+ 		F_ON(F_ENABLE_INCOMING,ps_global) &&
+ 		F_OFF(F_ENABLE_FAST_RECENT, ps_global)){
+ 		strcpy(tmp_20k_buf,
+ 		 "Format: Folder-name [Total New Messages/Total Messages]");
+ 		gf_puts(folder_list_center_space(tmp_20k_buf, cols), pc);
+ 		gf_puts(tmp_20k_buf, pc);
+ 		gf_puts("\n", pc);
+ 	    }
+ 
+ 
  	    gf_puts(repeat_char(cols, '-'), pc);
  	    gf_puts("\n\n", pc);
  	}
***************
*** 1992,1999 ****
--- 2011,2032 ----
  		    else if(c_list == fp->fs->list_cntxt)
  		      len += 4;			/* "[X] " */
  
+ 		    if (c_list->use & CNTXT_INCMNG &&
+ 			F_ON(F_ENABLE_INCOMING_CHECK,ps_global) &&
+ 			F_ON(F_ENABLE_INCOMING,ps_global)){
+ 			if(F_OFF(F_ENABLE_FAST_RECENT, ps_global)){
+ 			   len += strlen(comatose(f->countrecent));
+ 			   len += strlen(comatose(f->messages));
+ 			   len += 4;	/* "[/]" + "."/"_"/"~"/" " */
+ 			}
+ 			else
+ 			   len += 1;	/* " " */
+ 		    }
+ 		    len += 1;
+ 
  		    if(slot_size < len)
  		      slot_size = len;
+ 		    max_slot_size = slot_size;
  		}
  
  		if(F_ON(F_SINGLE_FOLDER_LIST, ps_global)){
***************
*** 2098,2104 ****
      int	       flags;
  {
      char      buf[256];
!     int	      l = 0;
      FOLDER_S *fp;
      HANDLE_S *h;
  
--- 2131,2137 ----
      int	       flags;
  {
      char      buf[256];
!     int	      l = 0, s = 0;
      FOLDER_S *fp;
      HANDLE_S *h;
  
***************
*** 2121,2126 ****
--- 2154,2164 ----
  	     && (*pc)(strlen(buf)) && gf_puts(buf, pc)) : 1)
         && (fp ? ((l = folder_list_write_prefix(fp, flags, pc)) >= 0
  		 && gf_puts(FLDR_NAME(fp), pc)
+ 		 && (s = folder_list_write_count(fp, ctxt, pc, l, 
+ 			(ps_global->last_folder_checked == fnum)
+ 			? 1 
+ 			: ((ps_global->first_folder_checked == fnum)
+ 			  ? -1 : 0))) >= 0
  		 && ((fp->isdir && fp->isfolder) ? (*pc)('[') : 1)
  		 && ((fp->isdir) ? (*pc)(ctxt->dir->delim) : 1)
  		 && ((fp->isdir && fp->isfolder) ? (*pc)(']') : 1))
***************
*** 2128,2134 ****
         && (h ? ((*pc)(TAG_EMBED) && (*pc)(TAG_BOLDOFF)
  		&& (*pc)(TAG_EMBED) && (*pc)(TAG_INVOFF)) : 1)){
  	if(fp){
! 	    l += strlen(FLDR_NAME(fp));
  	    if(fp->isdir)
  	      l += (fp->isfolder) ? 3 : 1;
  	}
--- 2166,2172 ----
         && (h ? ((*pc)(TAG_EMBED) && (*pc)(TAG_BOLDOFF)
  		&& (*pc)(TAG_EMBED) && (*pc)(TAG_INVOFF)) : 1)){
  	if(fp){
! 	    l += strlen(FLDR_NAME(fp)) + s;
  	    if(fp->isdir)
  	      l += (fp->isfolder) ? 3 : 1;
  	}
***************
*** 2139,2144 ****
--- 2177,2225 ----
      return(l);
  }
  
+ int
+ folder_list_write_count(f, ctxt, pc, l, is_last)
+     FOLDER_S *f;
+     CONTEXT_S *ctxt;
+     gf_io_t   pc;
+     int	      l, is_last;
+ {
+     int rv = 0, i;
+ 
+     if (ctxt->use & CNTXT_INCMNG &&
+ 	F_ON(F_ENABLE_INCOMING_CHECK,ps_global) &&
+ 	F_ON(F_ENABLE_INCOMING,ps_global)){
+ 	  rv = max_slot_size - strlen(FLDR_NAME(f)) - l;
+ 	  if(F_OFF(F_ENABLE_FAST_RECENT, ps_global)){
+ 	     rv -= strlen(comatose(f->countrecent));
+  	     rv -= strlen(comatose(f->messages));
+ 	     rv -= 3;
+ 	  }
+ 	  if(f->skipped)
+ 	    gf_puts(".", pc);
+ 	  else if(is_last > 0)
+ 	    gf_puts("_", pc);
+ 	  else if (is_last < 0)
+ 	    gf_puts("~", pc);
+ 	  if(f->skipped || is_last)
+ 	    rv--;
+ 
+ 	  rv -= 1; 	/* len += 1 was added as space between folders */
+ 	  if(F_OFF(F_ENABLE_FAST_RECENT, ps_global)){
+ 	     for (i = 0; i < rv; i++) gf_puts(" ", pc);
+ 	     gf_puts("[", pc);
+ 	     gf_puts(comatose(f->countrecent), pc);
+ 	     gf_puts("/", pc);
+ 	     gf_puts(comatose(f->messages), pc);
+ 	     gf_puts("]", pc);
+ 	     rv = max_slot_size - strlen(FLDR_NAME(f)) - l - 1;
+ 	  }
+ 	  else
+ 	     rv = max_slot_size - strlen(FLDR_NAME(f)) - l - 1 - rv;
+     }
+     return rv;
+ }
+ 
  
  int
  folder_list_write_prefix(f, flags, pc)
***************
*** 2224,2229 ****
--- 2305,2323 ----
  	      p = strchr(p, fs->context->dir->delim))
  	    name = ++p;
  
+ 	if(fs->context->use & CNTXT_INCMNG){
+ 	  FOLDER_S *f;
+ 	  int total = folder_total(FOLDERS(fs->context)), index;
+ 	  for(index = folder_index(ps_global->inbox_name, fs->context, FI_FOLDER);
+               index >= 0 && index < total
+ 	        && (f = folder_entry(index, FOLDERS(fs->context)))
+ 	        && !f->isdir; index++)
+ 	     if(!strcmp(fs->first_folder, f->name)){
+ 		name = FLDR_NAME(f);
+ 		break;
+ 	     }
+ 	}
+ 
  	for(h = handles; h; h = h->next)
  	  if(h->h.f.context == fs->context){
  	      if(!h_found)		/* match at least given context */
***************
*** 2462,2468 ****
  			   "Empty folder collection.  No folder to rename!");
  
  	break;
! 		     
  
              /*-------------- Delete --------------------*/
        case MC_DELETE :
--- 2556,2571 ----
  			   "Empty folder collection.  No folder to rename!");
  
  	break;
! 
! 
! 		/*------- Check incoming forlders -------*/
!       case MC_FORCECHECK:
! 	   ps_global->force_check_now = 1;
! 	   rv = (new_mail_incfolder(ps_global,MC_FORCECHECK) &&
! 		 (ps_global->refresh_list & IF_REFRESH_STRONG)) ? 1 : 0;
! 	   ps_global->refresh_list &= IF_REFRESH_NONE;
! 	break;
! 
  
              /*-------------- Delete --------------------*/
        case MC_DELETE :
***************
*** 2737,2746 ****
  			    tot = strm->nmsgs;
  			    rec = strm->recent;
  			}
  		    }
  		    else{
  			tot = strm->nmsgs;
! 			rec = sp_recent_since_visited(strm);
  		    }
  		}
  		/*
--- 2840,2853 ----
  			    tot = strm->nmsgs;
  			    rec = strm->recent;
  			}
+ 			if(folder->origrecent > rec)
+ 			   folder->origrecent = rec;
+ 			folder->countrecent = rec > folder->origrecent 
+ 						? rec - folder->origrecent : 0L;
  		    }
  		    else{
  			tot = strm->nmsgs;
! 			rec = folder->countrecent = sp_recent_since_visited(strm);
  		    }
  		}
  		/*
***************
*** 2759,2764 ****
--- 2866,2875 ----
  		       && mm_status_result.flags & SA_RECENT){
  			tot = mm_status_result.messages;
  			rec = mm_status_result.recent;
+ 			if(folder->origrecent > rec)
+ 			   folder->origrecent = rec;
+ 			folder->countrecent = rec > folder->origrecent
+ 						? rec - folder->origrecent : 0L;
  			gotit++;
  		    }
  		}
***************
*** 2771,2776 ****
--- 2882,2891 ----
  		    if(strm){
  			tot = strm->nmsgs;
  			rec = strm->recent;
+ 			if(folder->origrecent > rec)
+ 			   folder->origrecent = rec;
+ 			folder->countrecent = rec > folder->origrecent
+ 						? rec - folder->origrecent : 0L;
  			gotit++;
  			pine_mail_close(strm);
  		    }
***************
*** 2783,2792 ****
  		if(we_cancel)
  		  cancel_busy_alarm(-1);
  
! 		if(gotit)
  		  sprintf(tmp_output,
  			  "%lu total message%.2s, %lu of them recent",
  			  tot, plural(tot), rec);
  	    }
          }else
  	  strncpy(tmp_output, "No folder to check! Can't get recent info",
--- 2898,2917 ----
  		if(we_cancel)
  		  cancel_busy_alarm(-1);
  
! 		if(gotit){
  		  sprintf(tmp_output,
  			  "%lu total message%.2s, %lu of them recent",
  			  tot, plural(tot), rec);
+ 		  if(F_ON(F_ENABLE_INCOMING_CHECK,ps_global) 
+ 		     &&	F_ON(F_ENABLE_INCOMING,ps_global)
+ 		     && sparms->text.handles->h.f.context->use & CNTXT_INCMNG){
+ 		     ps_global->refresh_list |= IF_REFRESH_STRONG;
+ 		     if (rec > 0L)
+ 			folder->notified = 1;
+ 		     folder->selected = folder->countrecent > 0L 
+ 					? 1 : folder->user_selected;
+ 		  }
+ 		}
  	    }
          }else
  	  strncpy(tmp_output, "No folder to check! Can't get recent info",
***************
*** 3323,3330 ****
  	  case 'f' :			/* flip selection */
  	    n = folder_total(FOLDERS(context));
  	    for(total = i = 0; i < n; i++)
! 	      if(f = folder_entry(i, FOLDERS(context)))
  		f->selected = !f->selected;
  
  	    return(1);			/* repaint */
  
--- 3448,3457 ----
  	  case 'f' :			/* flip selection */
  	    n = folder_total(FOLDERS(context));
  	    for(total = i = 0; i < n; i++)
! 	      if(f = folder_entry(i, FOLDERS(context))){
  		f->selected = !f->selected;
+ 		f->user_selected = f->selected;
+ 	      }
  
  	    return(1);			/* repaint */
  
***************
*** 3467,3481 ****
      CONTEXT_S *context;
  {
      int	      i, n, total;
  
      n = folder_total(FOLDERS(context));
!     for(total = i = 0; i < n; i++)
!       if(folder_entry(i, FOLDERS(context))->selected)
  	total++;
  
      return(total);
  }
  
  
  SELECTED_S *
  new_selected()
--- 3594,3657 ----
      CONTEXT_S *context;
  {
      int	      i, n, total;
+     FOLDER_S  *f;
  
      n = folder_total(FOLDERS(context));
!     for(total = i = 0; i < n; i++){
!       f = folder_entry(i, FOLDERS(context));
!       if(f->selected) 
  	total++;
+     }
  
      return(total);
  }
  
+ void
+ update_incoming_folder_data(stream, context)
+  MAILSTREAM *stream;
+  CONTEXT_S  *context;
+ {
+  FOLDER_S *f = incoming_folder_data(stream, context);
+ 
+   if(f){
+      f->origrecent = f->recent = stream->recent;
+      f->messages   = stream->nmsgs;
+   }
+ }
+ 
+ 
+ FOLDER_S *
+ incoming_folder_data(stream, cntxt)
+  MAILSTREAM *stream;
+  CONTEXT_S  *cntxt;
+ {
+    long index, total, done = 0;
+    FOLDER_S *f = NULL;
+ 
+    if (cntxt && cntxt->use & CNTXT_INCMNG){
+       total = folder_total(FOLDERS(cntxt));
+       for (index = 0L; index < total ; index++){ 
+ 	 f = folder_entry(index, FOLDERS(cntxt));
+ 	 if (!strcmp(STREAMNAME(stream), FLDR_NAME(f))){
+ 	     done++;
+ 	     break;
+ 	}
+       }
+    }
+    if (!done)
+      f = NULL;
+    return f;
+ }
+ 
+ int
+ need_folder_report(folder)
+   char *folder;
+ {
+   return (ps_global->VAR_INCOMING_FOLDERS_CHECK &&
+ 	 ((ps_global->VAR_INCOMING_FOLDERS_CHECK[0] == '*') ||
+ 	  strstr(ps_global->VAR_INCOMING_FOLDERS_CHECK, folder)));
+ }
+ 
  
  SELECTED_S *
  new_selected()
***************
*** 4204,4209 ****
--- 4380,4386 ----
  
      if(f = folder_entry(index, FOLDERS(context))){
        f->selected = !f->selected;
+       f->user_selected = f->selected;
        return((*func)(context, index));
      }
      return 1;
***************
*** 7223,7228 ****
--- 7400,7408 ----
      FOLDERS(context) = init_folder_entries();
      init_incoming_folder_list(ps_global, context);
      init_inbox_mapping(ps_global->VAR_INBOX_PATH, context);
+     ps_global->force_check_now = 1;	/* sorry about this */
+     new_mail_incfolder(ps_global,MC_FORCECHECK);
+     ps_global->refresh_list |= IF_REFRESH_STRONG;
  }
  
  
***************
*** 8596,8601 ****
--- 8776,8946 ----
  
  
  /*
+  * next_folder - given a current folder in a context, return the next in
+  *               the list, or NULL if no more or there's a problem.
+  */
+ int
+ next_folder_check(streamp, cntxt, find_recent, find_messages, f, opstrm)
+     MAILSTREAM **streamp;
+     CONTEXT_S	*cntxt;
+     long	*find_recent, *find_messages;
+     FOLDER_S 	*f;
+     int		*opstrm;
+ {
+     char      *next;
+     int       index, failed_status = 0;
+ 
+     /* note: find_folders may assign "stream" */
+     build_folder_list(streamp, cntxt, NULL, NULL, BFL_NONE);
+ 
+     if(find_recent && find_messages && opstrm){
+       MAILSTREAM *stream = NULL;
+       int         rv, we_cancel = 0;
+       char        msg_buf[MAX_SCREEN_COLS+1] = {'\0'};
+       char        tmp[MAILTMPLEN];
+ 
+       *opstrm	     = 0;		/* default value */
+       *find_recent   = f->recent;	/* default value. Return this if */
+       *find_messages = f->messages;	/* not requested		 */
+ 
+       if(((stream = sp_stream_get(context_apply(tmp, cntxt, f->name,sizeof(tmp)),
+ 					SP_MATCH | SP_RO_OK)) != NULL)
+ 	   || ((stream = already_open_stream(tmp, AOS_NONE)) != NULL)){
+ 	  *opstrm = 1;
+ 	  (void) pine_mail_ping(stream);
+ 	  if(stream == ps_global->mail_stream){
+ 	    next = new_mail_in_open_stream(stream, find_recent, find_messages);
+ 	    if(f->origrecent > *find_recent)
+ 	       f->origrecent = *find_recent;
+ 	    if(ps_global->in_fld_list)
+ 	       f->notified = f->countrecent == 0 
+ 				? (*find_recent == f->recent)
+ 			       	   && (*find_messages == f->messages)
+ 				: 1;
+ 	    f->countrecent = *find_recent > f->origrecent 
+ 				? *find_recent - f->origrecent : 0L;
+ 	  }
+ 	  else{
+ 	    *find_recent   = f->countrecent = sp_recent_since_visited(stream);
+ 	    *find_messages = stream->nmsgs;
+ 	    next = *find_recent ? STREAMNAME(stream) : NULL;
+ 	  }
+ 	  free_folder_list(cntxt);
+ 	  return next ? 1 : 0;
+       } 
+       else if ((F_ON(F_ENABLE_FAST_RECENT, ps_global) &&
+ 		F_OFF(F_ENABLE_INCOMING_RECHECK,ps_global)  && 
+ 		(f->notified || f->selected))
+ 		|| (f->selected && f->user_selected)){
+ 
+ 	  next = f->notified ? FLDR_NAME(f) : NULL;
+ 	  free_folder_list(cntxt);
+ 	  return next ? 1 : 0;
+       }
+       else if (need_folder_report(FLDR_NAME(f))
+ 		&& (strcmp(ps_global->cur_folder, FLDR_NAME(f)) || !stream)){
+ 
+ 	  we_cancel = busy_alarm(1, msg_buf, NULL, 1);
+ 
+ 	  /* First, get a stream for the test */
+ 	  if(streamp && *streamp){
+ 	     if(context_same_stream(cntxt, f->name, *streamp))
+ 		stream = *streamp;
+ 	     else{
+ 		mail_close(*streamp);
+ 		*streamp = NULL;
+ 	     }
+ 	   }
+ 
+ 	  if(!stream)
+ 	      stream = sp_stream_get(context_apply(tmp, cntxt, f->name,
+ 						   sizeof(tmp)), SP_SAME);
+ 
+ 	  if(!stream){
+ 	     if(!(stream = sp_stream_status_get(
+ 				context_apply(tmp, cntxt, f->name,
+ 				 sizeof(tmp))))){
+ 	        stream = (*f->name == '{') 
+ 			  ? mail_open (NIL,f->name,OP_HALFOPEN) : NIL;
+ 		sp_add_status(stream);
+ 	     }
+ 	  }
+ 
+ 	  if(F_OFF(F_ENABLE_FAST_RECENT, ps_global)
+ 	     || !((rv = folder_exists(cntxt,f->name))
+ 					     & (FEX_ISMARKED | FEX_UNMARKED))){
+ 	      extern MAILSTATUS mm_status_result;
+ 
+ 	      if((F_ON(F_ENABLE_FAST_RECENT, ps_global) &&
+ 	          (rv == 0 || rv & FEX_ERROR))){
+ 		  failed_status = 1;
+ 		  mm_status_result.flags = 0L;
+ 	      }
+ 	      else{
+ 		  if(stream){
+ 		      if(!context_status_full(cntxt, stream,
+ 					      f->name, SA_RECENT | SA_MESSAGES,
+ 					      &f->uidvalidity,
+ 					      &f->uidnext)){
+ 			  failed_status = 1;
+ 			  mm_status_result.flags = 0L;
+ 		      }
+ 		  }
+ 		  else{
+ 		      if(!context_status_streamp_full(cntxt, streamp, f->name,
+ 						      SA_RECENT | SA_MESSAGES,
+ 						      &f->uidvalidity,
+ 						      &f->uidnext)
+ 				|| (IS_REMOTE(f->name) && !*streamp)){
+ 			  failed_status = 1;
+ 			  mm_status_result.flags = 0L;
+ 		      }
+ 		  }
+ 	      }
+ 
+ 	      if (!failed_status){
+ 		*find_messages = mm_status_result.messages;
+ 		*find_recent   = mm_status_result.recent;
+ 	      }
+ 	      else{
+ 		/* We failed, so return old data, even if this is wrong.
+ 		   We can not zero out the values because the failure may
+ 		   be temporary and in this case when the folder is back
+ 		   we would find new mail that simply does not exist in
+ 		   the folder.
+ 		 */
+ 		mm_status_result.messages = f->messages;
+ 		mm_status_result.recent = f->recent;
+ 	      }
+ 	      rv = (((mm_status_result.flags & SA_RECENT) ||
+ 		      (F_OFF(F_ENABLE_FAST_RECENT,ps_global) 
+ 			&& (mm_status_result.recent != f->recent)))
+ 		    && (*find_recent = mm_status_result.recent))
+ 		     ? FEX_ISMARKED : 0;
+ 	  }
+ 
+ 	  if(we_cancel)
+ 	    cancel_busy_alarm(0);
+ 
+ 	  failed_status = 0;
+ 
+ 	  if(f->origrecent > *find_recent)
+ 	     f->origrecent = *find_recent;
+ 	  if(rv & FEX_ISMARKED){
+ 	    next = f ? FLDR_NAME(f) : NULL;
+   	    free_folder_list(cntxt);
+ 	    f->countrecent = *find_recent > f->origrecent 
+ 				? *find_recent - f->origrecent : 0L;
+     	    return next ? 1 : 0;
+ 	  }
+       }
+       return 0;
+     }
+ }
+ 
+ 
+ 
+ /*
   * folder_is_nick - check to see if the given name is a nickname
   *                  for some folder in the given context...
   *
diff -rc pine4.64/pine/help.c pine4.64.incoming/pine/help.c
*** pine4.64/pine/help.c	Tue Nov 23 10:29:47 2004
--- pine4.64.incoming/pine/help.c	Mon Oct 30 22:42:34 2006
***************
*** 168,174 ****
      int	      flags;
  {
      char	  **shown_text;
!     int		    cmd = MC_NONE;
      long	    offset = 0L;
      char	   *error = NULL, tmp_title[MAX_SCREEN_COLS + 1];
      STORE_S	   *store;
--- 168,174 ----
      int	      flags;
  {
      char	  **shown_text;
!     int		    cmd = MC_NONE, in_fld_list;
      long	    offset = 0L;
      char	   *error = NULL, tmp_title[MAX_SCREEN_COLS + 1];
      STORE_S	   *store;
***************
*** 181,186 ****
--- 181,188 ----
  
      dprint(1, (debugfile, "\n\n    ---- HELPER ----\n"));
  
+     in_fld_list = ps_global->in_fld_list;
+     ps_global->in_fld_list = 0;
  #ifdef	HELPFILE
      if(otext)
        shown_text = otext;
***************
*** 396,401 ****
--- 398,404 ----
        free_list_array(&dynamic_text);
  #endif
  
+     ps_global->in_fld_list = in_fld_list;
      return(cmd);
  }
  
diff -rc pine4.64/pine/imap.c pine4.64.incoming/pine/imap.c
*** pine4.64/pine/imap.c	Mon Sep 12 15:04:25 2005
--- pine4.64.incoming/pine/imap.c	Mon Oct 30 22:42:34 2006
***************
*** 694,699 ****
--- 694,700 ----
      int       len, rc, q_line, flags;
      int       oespace, avail, need, save_dont_use;
      struct servent *sv;
+     time_t    now;
  #define NETMAXPASSWD 100
  
      dprint(9, (debugfile, "mm_login trial=%ld user=%s service=%s%s%s\n",
***************
*** 702,710 ****
  	       mb->port ? " port=" : "",
  	       mb->port ? comatose(mb->port) : ""));
      q_line = -(ps_global->ttyo ? ps_global->ttyo->footer_rows : 3);
  
      /* make sure errors are seen */
!     if(ps_global->ttyo)
        flush_status_messages(0);
  
      /*
--- 703,712 ----
  	       mb->port ? " port=" : "",
  	       mb->port ? comatose(mb->port) : ""));
      q_line = -(ps_global->ttyo ? ps_global->ttyo->footer_rows : 3);
+     now = time(0);
  
      /* make sure errors are seen */
!     if(ps_global->ttyo && !ps_global->checking_incfld)
        flush_status_messages(0);
  
      /*
***************
*** 1217,1222 ****
--- 1219,1225 ----
          return;
      }
  
+     ps_global->login_time = time(0) - now;
   nopwpmt:
      /* remember the password for next time */
      if(F_OFF(F_DISABLE_PASSWORD_CACHING,ps_global))
***************
*** 1950,1960 ****
--- 1953,1967 ----
  #endif
  
      if(elapsed >= (long)ps_global->tcp_query_timeout){
+       if(!ps_global->checking_incfld){
  	sprintf(pmt,
  	 "Waited %s seconds for server reply.  Break connection to server",
  		long2string(elapsed));
  	if(want_to(pmt, 'n', 'n', NO_HELP, WT_FLUSH_IN) == 'y')
  	  return(0L);
+       }
+       else
+ 	rv = 0L;
      }
  
      return(rv);
***************
*** 1996,2001 ****
--- 2003,2009 ----
      if(elapsed >= (long)ps_global->tcp_query_timeout){
  	int clear_inverse;
  
+       if(!ps_global->checking_incfld){
  	ClearLine(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global));
  	if(clear_inverse = !InverseState())
  	  StartInverse();
***************
*** 2016,2021 ****
--- 2024,2032 ----
  	  EndInverse();
  
  	ClearLine(ps_global->ttyo->screen_rows - FOOTER_ROWS(ps_global));
+       }
+       else
+ 	rv = 0L;
      }
  
      if(rv == 1L){			/* just warn 'em something's up */
diff -rc pine4.64/pine/init.c pine4.64.incoming/pine/init.c
*** pine4.64/pine/init.c	Mon Sep 12 11:53:17 2005
--- pine4.64.incoming/pine/init.c	Mon Oct 30 22:42:34 2006
***************
*** 71,76 ****
--- 71,77 ----
  typedef enum {Sapling, Seedling, Seasoned} FeatureLevel;
  
  #define	TO_BAIL_THRESHOLD	60
+ #define	INCFLD_THRESHOLD	5
  
  #define METASTR "\nremote-abook-metafile="
  static char meta_prefix[] = ".ab";
***************
*** 158,163 ****
--- 159,166 ----
  
  CONF_TXT_T cf_text_incoming_folders[] =	"List of incoming msg folders besides INBOX, e.g. ={host2}inbox, {host3}inbox\n# Syntax: optnl-label {optnl-imap-host-name}folder-path";
  
+ CONF_TXT_T cf_incoming_folders_check[] = "List of incoming folders to be checked for new mail";
+ 
  CONF_TXT_T cf_text_folder_collections[] =	"List of directories where saved-message folders may be. First one is\n# the default for Saves. Example: Main {host1}mail/[], Desktop mail\\[]\n# Syntax: optnl-label {optnl-imap-hostname}optnl-directory-path[]";
  
  CONF_TXT_T cf_text_news_collections[] =	"List, only needed if nntp-server not set, or news is on a different host\n# than used for NNTP posting. Examples: News *[] or News *{host3/nntp}[]\n# Syntax: optnl-label *{news-host/protocol}[]";
***************
*** 242,247 ****
--- 245,252 ----
  
  CONF_TXT_T cf_text_inc_startup[] =	"Sets message which cursor begins on. Choices: first-unseen, first-recent,\n# first-important, first-important-or-unseen, first-important-or-recent,\n# first, last. Default: \"first-unseen\".";
  
+ CONF_TXT_T cf_text_inc_check[] =	"Sets how and when checks for new mail should happen. Choices: automatic,\n# automatic-after-first-manual-check, manual-only, Default: automatic";
+ 
  CONF_TXT_T cf_pruning_rule[] =		"Allows a default answer for the prune folder questions. Choices: yes-ask,\n# yes-no, no-ask, no-no, ask-ask, ask-no. Default: \"ask-ask\".";
  
  CONF_TXT_T cf_reopen_rule[] =		"Controls behavior when reopening an already open folder.";
***************
*** 378,383 ****
--- 383,390 ----
  
  CONF_TXT_T cf_text_tcp_query_timeo[] =	"If this much time has elapsed at the time of a tcp read or write\n# timeout, pine will ask if you want to break the connection.\n# Default is 60 seconds, minimum is 5, maximum is 1000.";
  
+ CONF_TXT_T cf_text_inc_fld_timeout[] =	"If this much time has elapsed at the time of a tcp read or write\n# timeout while checking for new mail in an incoming folder, pine will break the connection.\n# Default is 5 seconds, minimum is 2, maximum is 60.";
+ 
  CONF_TXT_T cf_text_rsh_open_timeo[] =	"Sets the time in seconds that Pine will attempt to open a UNIX remote\n# shell connection.  The default is 15, min is 5, and max is unlimited.\n# Zero disables rsh altogether.";
  
  CONF_TXT_T cf_text_rsh_path[] =		"Sets the name of the command used to open a UNIX remote shell connection.\n# The default is typically /usr/ucb/rsh.";
***************
*** 471,476 ****
--- 478,485 ----
  				cf_text_nntp_server},
  {"inbox-path",				0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
  				cf_text_inbox_path},
+ {"incoming-folders-to-check",		0, 1, 0, 1, 1, 0, 0, 0, 0, 0,
+ 				cf_incoming_folders_check},
  {"incoming-archive-folders",		0, 1, 0, 1, 1, 1, 0, 0, 0, 0,
  				cf_text_archived_folders},
  {"pruned-folders",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1,
***************
*** 519,524 ****
--- 528,535 ----
  				cf_text_goto_default},
  {"incoming-startup-rule",		0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
  				cf_text_inc_startup},
+ {"incoming-check-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
+ 				cf_text_inc_check},  
  {"pruning-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
  				cf_pruning_rule},
  {"folder-reopen-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
***************
*** 673,678 ****
--- 684,691 ----
  				cf_text_tcp_write_timeo},
  {"tcp-query-timeout",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
  				cf_text_tcp_query_timeo},
+ {"inc-fld-timeout",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
+ 				cf_text_inc_fld_timeout},
  {"rsh-command",				0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
  				cf_text_rsh_command},
  {"rsh-path",				0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
***************
*** 1507,1512 ****
--- 1520,1526 ----
      GLO_REMOTE_ABOOK_VALIDITY	= cpystr(DF_REMOTE_ABOOK_VALIDITY);
      GLO_GOTO_DEFAULT_RULE	= cpystr(DF_GOTO_DEFAULT_RULE);
      GLO_INCOMING_STARTUP	= cpystr(DF_INCOMING_STARTUP);
+     GLO_INCOMING_RULE		= cpystr(DF_INCOMING_RULE);
      GLO_PRUNING_RULE		= cpystr(DF_PRUNING_RULE);
      GLO_REOPEN_RULE		= cpystr(DF_REOPEN_RULE);
      GLO_THREAD_DISP_STYLE	= cpystr(DF_THREAD_DISP_STYLE);
***************
*** 2082,2087 ****
--- 2096,2108 ----
      else
        ps->tcp_query_timeout = i;
  
+     set_current_val(&vars[V_INCFLDTIMEO], TRUE, TRUE);
+     ps->incfld_timeout = i = INCFLD_THRESHOLD;
+     if(VAR_INCFLDTIMEO && SVAR_INCFLDQUERY(ps, i, tmp_20k_buf))
+       init_error(ps, SM_ORDER | SM_DING, 3, 5, tmp_20k_buf);
+     else
+       ps->incfld_timeout = i;
+ 
      set_current_val(&vars[V_NEWSRC_PATH], TRUE, TRUE);
      if(VAR_NEWSRC_PATH && VAR_NEWSRC_PATH[0])
        mail_parameters(NULL, SET_NEWSRC, (void *)VAR_NEWSRC_PATH);
***************
*** 2329,2334 ****
--- 2350,2356 ----
      set_current_val(&vars[V_PRUNED_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_ARCHIVED_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_INCOMING_FOLDERS], TRUE, TRUE);
+     set_current_val(&vars[V_INCOMING_FOLDERS_CHECK], TRUE, TRUE);
      set_current_val(&vars[V_SORT_KEY], TRUE, TRUE);
      if(decode_sort(VAR_SORT_KEY, &ps->def_sort, &def_sort_rev) == -1){
  	sprintf(tmp_20k_buf, "Sort type \"%.200s\" is invalid", VAR_SORT_KEY);
***************
*** 2366,2371 ****
--- 2388,2394 ----
      cur_rule_value(&vars[V_TITLEBAR_COLOR_STYLE], TRUE, TRUE);
      cur_rule_value(&vars[V_FLD_SORT_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_INCOMING_STARTUP], TRUE, TRUE);
+     cur_rule_value(&vars[V_INCOMING_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_PRUNING_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_REOPEN_RULE], TRUE, TRUE);
      cur_rule_value(&vars[V_GOTO_DEFAULT_RULE], TRUE, TRUE);
***************
*** 2667,2672 ****
--- 2690,2699 ----
  	 F_ENABLE_DOT_FOLDERS, h_config_enable_dot_folders, PREF_FLDR},
  	{"enable-incoming-folders",
  	 F_ENABLE_INCOMING, h_config_enable_incoming, PREF_FLDR},
+ 	{"enable-check-incoming-folders",
+ 	 F_ENABLE_INCOMING_CHECK, h_config_enable_check_incoming, PREF_FLDR},
+ 	{"recheck-all-incoming-folders",
+ 	 F_ENABLE_INCOMING_RECHECK, h_config_enable_recheck_incoming,PREF_FLDR},
  	{"enable-lame-list-mode",
  	 F_FIX_BROKEN_LIST, h_config_lame_list_mode, PREF_FLDR},
  	{"expanded-view-of-folders",
***************
*** 3773,3778 ****
--- 3800,3822 ----
  	   ? &is_rules[index] : NULL);
  }
  
+ /*
+  * Standard way to get  incoming check rules...
+  */
+ NAMEVAL_S *
+ incoming_check_rules(index)
+     int index;
+ {
+     static NAMEVAL_S is_rules[] = {
+ 	{"automatic",				NULL, IC_AUTO},
+ 	{"automatic-after-first-manual-check",	NULL, IC_MAN_AUTO},
+ 	{"manual-only",				NULL, IC_MAN}
+     };
+ 
+     return((index >= 0 && index < (sizeof(is_rules)/sizeof(is_rules[0])))
+ 	   ? &is_rules[index] : NULL);
+ }
+ 
  
  NAMEVAL_S *
  startup_rules(index)
***************
*** 11053,11058 ****
--- 11097,11110 ----
  	      break;
  	  }
      }
+     else if(var == &ps_global->vars[V_INCOMING_RULE]){
+       if(ps_global->VAR_INCOMING_RULE)
+ 	for(i = 0; v = incoming_check_rules(i); i++)
+ 	  if(!strucmp(ps_global->VAR_INCOMING_RULE, S_OR_L(v))){
+ 	      ps_global->inc_check_rule = v->value;
+ 	      break;
+ 	  }
+     }
      else if(var == &ps_global->vars[V_PRUNING_RULE]){
        if(ps_global->VAR_PRUNING_RULE)
  	for(i = 0; v = pruning_rules(i); i++)
diff -rc pine4.64/pine/mailcmd.c pine4.64.incoming/pine/mailcmd.c
*** pine4.64/pine/mailcmd.c	Mon Sep 12 15:04:25 2005
--- pine4.64.incoming/pine/mailcmd.c	Mon Oct 30 22:42:34 2006
***************
*** 1256,1261 ****
--- 1256,1262 ----
  	ps_global->expunge_in_progress = 0;
  	if(we_cancel)
  	  cancel_busy_alarm((sp_expunge_count(stream) > 0) ? 0 : -1);
+ 	update_incoming_folder_data(stream, state->context_current);
  
  	dprint(2,(debugfile,"expunge complete cur:%ld max:%ld\n",
  		  mn_get_cur(msgmap), mn_get_total(msgmap)));
***************
*** 1533,1538 ****
--- 1534,1545 ----
  	break;
  
  
+          /*--------Incoming Folders Auto Check --------*/
+       case MC_FORCECHECK:
+ 	state->force_check_now = 1;
+ 	new_mail_incfolder(state,command);
+ 	break;
+ 
            /*--------- Default, unknown command ----------*/
        default:
  	panic("Unexpected command case");
***************
*** 8423,8428 ****
--- 8430,8436 ----
            temp[MAILTMPLEN+1], buff1[MAX_SCREEN_COLS+1], *moved_msg = NULL,
  	  buff2[MAX_SCREEN_COLS+1], *folder;
      CONTEXT_S *context;
+     FOLDER_S  *f;
      struct variable *vars = ps_global->vars;
      int ret, expunge = FALSE, no_close = 0;
      char ing[4];
***************
*** 8439,8445 ****
      }
  
      if(stream != NULL){
! 	context = sp_context(stream);
  	folder  = STREAMNAME(stream);
  
          dprint(2, (debugfile, "expunge_and_close: \"%s\"%s\n",
--- 8447,8453 ----
      }
  
      if(stream != NULL){
! 	context = ps_global->context_current;
  	folder  = STREAMNAME(stream);
  
          dprint(2, (debugfile, "expunge_and_close: \"%s\"%s\n",
***************
*** 8452,8457 ****
--- 8460,8473 ----
  	buff1[0] = '\0';
  	buff2[0] = '\0';
  
+ 	if(F_OFF(F_ENABLE_FAST_RECENT,ps_global) &&
+ 	   (f = incoming_folder_data(stream, context))){
+ 	   new_mail_in_open_stream(stream, &(f->origrecent), &(f->messages));
+ 	   f->notified    = 0;
+ 	   f->countrecent = f->recent = 0L;
+ 	   f->selected    = f->user_selected;
+ 	}
+ 
          if(!stream->rdonly){
  
  	    if(!no_close){
diff -rc pine4.64/pine/mailindx.c pine4.64.incoming/pine/mailindx.c
*** pine4.64/pine/mailindx.c	Tue May  3 15:00:53 2005
--- pine4.64.incoming/pine/mailindx.c	Mon Oct 30 22:42:34 2006
***************
*** 112,118 ****
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	NULL_MENU,
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
  	NULL_MENU,
  	NULL_MENU};
--- 112,118 ----
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	{"^H","ChkIncFl",{MC_FORCECHECK,1,{ctrl('H')}},KS_NONE},
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
  	NULL_MENU,
  	NULL_MENU};
***************
*** 197,203 ****
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	NULL_MENU,
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
  	NULL_MENU,
  	NULL_MENU};
--- 197,203 ----
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	{"^H","ChkIncFl",{MC_FORCECHECK,1,{ctrl('H')}},KS_NONE},
  	{"/","Collapse/Expand",{MC_COLLAPSE,1,{'/'}},KS_NONE},
  	NULL_MENU,
  	NULL_MENU};
***************
*** 592,597 ****
--- 592,598 ----
  	return;
      }
  
+     state->redrawer    = redraw_index_body;
      state->prev_screen = mail_index_screen;
      state->next_screen = SCREEN_FUN_NULL;
  
***************
*** 702,720 ****
       MAILSTREAM  *stream;
       MSGNO_S     *msgmap;
  {
!     int		 ch, cmd, which_keys, force,
  		 cur_row, cur_col, km_popped, paint_status;
      int          old_day = -1;
!     long	 i, j, k, old_max_msgno;
      IndexType    style, old_style = MsgIndex;
      struct index_state id;
      struct key_menu *km = NULL;
  #if defined(DOS) || defined(OS2)
      extern void (*while_waiting)();
  #endif
  
      dprint(1, (debugfile, "\n\n ---- INDEX MANAGER ----\n"));
!     
      ch                    = 'x';	/* For displaying msg 1st time thru */
      force                 = 0;
      km_popped             = 0;
--- 703,731 ----
       MAILSTREAM  *stream;
       MSGNO_S     *msgmap;
  {
!     int		 ch, cmd, which_keys, force, skip = 0,
  		 cur_row, cur_col, km_popped, paint_status;
      int          old_day = -1;
!     long	 i, j, k, old_max_msgno, nm;
      IndexType    style, old_style = MsgIndex;
      struct index_state id;
      struct key_menu *km = NULL;
+     FOLDER_S *f;
  #if defined(DOS) || defined(OS2)
      extern void (*while_waiting)();
  #endif
  
      dprint(1, (debugfile, "\n\n ---- INDEX MANAGER ----\n"));
!     if (f = incoming_folder_data(stream, cntxt)){
! 	f->selected    = f->user_selected; /* unselect this folder now */
! 	f->origrecent  = stream->recent;   /* more accurate than  f->recent */
! 	f->notified    = 1;		   /* no updates in this screen */
! 	f->countrecent = 0;		   /* Yes, we want new mail only */
! 	f->skipped     = 0;		   /* Erase the ".", if any */
! 	f->last_check_time = 0;		   /* and assume no delay for now */
! 	if(!selected_folders(cntxt) && (cntxt->use & CNTXT_ZOOM))
! 	  cntxt->use &= ~CNTXT_ZOOM;	   /* exit zoom mode if necessary */
!     }
      ch                    = 'x';	/* For displaying msg 1st time thru */
      force                 = 0;
      km_popped             = 0;
***************
*** 749,757 ****
  	}
  
  	/*------- Check for new mail -------*/
!         new_mail(force, NM_TIMING(ch), NM_STATUS_MSG);
! 	force = 0;			/* may not need to next time around */
! 
  	/*
  	 * If the width of the message number field in the display changes
  	 * we need to flush the cache and redraw. When the cache is cleared
--- 760,783 ----
  	}
  
  	/*------- Check for new mail -------*/
!         nm = new_mail(force, NM_TIMING(ch), NM_STATUS_MSG);
! 	if (!skip || nm > 0L){
! 	   if(nm > 0L)
! 	     state->force_check_now = 1;
! 	   if(f)
! 	     f->notified = 1;
! 	   new_mail_incfolder(state, MC_IFAUTOCHECK);
! 	}
! 	if (f){
! 	   long rec, tot;
! 	   new_mail_in_open_stream(stream, &rec, &tot);
! 	   f->countrecent = 0;
! 	   f->selected = f->user_selected;
! 	   f->recent   = rec;
! 	   f->messages = tot;
! 	}
! 	ps_global->refresh_list &= IF_REFRESH_NONE;
! 	force = skip = 0;		/* may not need to next time around */
  	/*
  	 * If the width of the message number field in the display changes
  	 * we need to flush the cache and redraw. When the cache is cleared
***************
*** 943,948 ****
--- 969,977 ----
  	      break;
  	  }
  
+ 	if ((cmd != MC_NONE) && (cmd != MC_FORCECHECK))
+            state->force_check_now = 0;
+ 
  	/*----------- Execute the command ------------------*/
  	switch(cmd){
  
***************
*** 1401,1407 ****
  	    }
  	    /* else fall thru to normal default */
  
! 
              /*---------- Default -- all other command ----------*/
            default:
     do_the_default:
--- 1430,1439 ----
  	    }
  	    /* else fall thru to normal default */
  
!           case MC_TAB:
! 		skip++;
!         /* do not check for new mail in inc fldrs and fall through */ 
!             
              /*---------- Default -- all other command ----------*/
            default:
     do_the_default:
diff -rc pine4.64/pine/mailview.c pine4.64.incoming/pine/mailview.c
*** pine4.64/pine/mailview.c	Tue Sep 20 11:26:20 2005
--- pine4.64.incoming/pine/mailview.c	Mon Oct 30 22:42:35 2006
***************
*** 235,241 ****
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
  	RCOMPOSE_MENU,
! 	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
--- 235,241 ----
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
  	RCOMPOSE_MENU,
! 	{"^H","ChkIncFl",{MC_FORCECHECK,1,{ctrl('H')}},KS_NONE},	
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
***************
*** 420,425 ****
--- 420,426 ----
      HANDLE_S	   *handles = NULL;
      SCROLL_S	    scrollargs;
      SourceType	    src = CharStar;
+     FOLDER_S *f = NULL;
  
      dprint(1, (debugfile, "\n\n  -----  MAIL VIEW  -----\n"));
  
***************
*** 7215,7221 ****
      register long    cur_top_line,  num_display_lines;
      int              result, done, ch, cmd, found_on, found_on_col,
  		     first_view, force, scroll_lines, km_size,
! 		     cursor_row, cursor_col, km_popped;
      long             jn;
      struct key_menu *km;
      HANDLE_S	    *next_handle;
--- 7216,7222 ----
      register long    cur_top_line,  num_display_lines;
      int              result, done, ch, cmd, found_on, found_on_col,
  		     first_view, force, scroll_lines, km_size,
! 		     cursor_row, cursor_col, km_popped, nm;
      long             jn;
      struct key_menu *km;
      HANDLE_S	    *next_handle;
***************
*** 7422,7428 ****
  
  	/*============ Check for New Mail and CheckPoint ============*/
          if(!sparms->quell_newmail &&
! 	   new_mail(force, NM_TIMING(ch), NM_STATUS_MSG) >= 0){
  	    update_scroll_titlebar(cur_top_line, 1);
  	    if(ps_global->mangled_footer)
                draw_keymenu(km, bitmap, ps_global->ttyo->screen_cols,
--- 7423,7430 ----
  
  	/*============ Check for New Mail and CheckPoint ============*/
          if(!sparms->quell_newmail &&
! 	   (nm = new_mail(force, NM_TIMING(ch), NM_STATUS_MSG)) >= 0){
! 	    ps_global->force_check_now = nm > 0 ? 1 : 0;
  	    update_scroll_titlebar(cur_top_line, 1);
  	    if(ps_global->mangled_footer)
                draw_keymenu(km, bitmap, ps_global->ttyo->screen_cols,
***************
*** 7430,7435 ****
--- 7432,7452 ----
  
  	    ps_global->mangled_footer = 0;
  	}
+ 	ps_global->in_pico = 0;
+ 
+ 	if (!sparms->quell_newmail && !ps_global->skip_ifcheck)
+ 	 new_mail_incfolder(ps_global, MC_IFAUTOCHECK);
+ 	ps_global->skip_ifcheck = 0;
+ 	if (ps_global->refresh_list){
+ 	   if(ps_global->in_fld_list &&
+ 	       ((ps_global->refresh_list & IF_REFRESH_STRONG) 
+ 		  || (ps_global->refresh_list & IF_REFRESH_WEAK
+ 		&& (sparms->text.handles->h.f.context->use & CNTXT_INCMNG))))
+ 	      cmd = MC_RESIZE;
+ 	   ps_global->refresh_list &= IF_REFRESH_NONE;
+ 	   if(cmd == MC_RESIZE)
+ 	      goto end;
+ 	}
  
  	/*
  	 * If an expunge of the current message happened during the
***************
*** 7564,7569 ****
--- 7581,7587 ----
  	      break;
  	  }
  
+         ps_global->force_check_now = (((cmd == MC_NONE) || (cmd == MC_FORCECHECK)) ? 1 : 0);
  
  	/*============= Execute command =======================*/
  	switch(cmd){
***************
*** 8308,8314 ****
--- 8326,8352 ----
  
              break;
  
+                 /*------- Check incoming folders -------*/
+            case MC_FORCECHECK:
+ 	      ps_global->force_check_now = 1;
+ 	      if (new_mail_incfolder(ps_global,MC_FORCECHECK) && 
+ 		   ps_global->refresh_list){
+ 		   if(ps_global->in_fld_list &&
+ 		       ((ps_global->refresh_list & IF_REFRESH_STRONG) 
+ 			  || (ps_global->refresh_list & IF_REFRESH_WEAK
+ 			&& (sparms->text.handles->h.f.context->use 
+ 							& CNTXT_INCMNG))))
+ 		      cmd = MC_RESIZE;
+ 		   ps_global->refresh_list &= IF_REFRESH_NONE;
+ 		   if(cmd == MC_RESIZE)
+ 		      goto end;
+ 	      }
+ 	     break;
  
+            case MC_TAB:
+ 		ps_global->skip_ifcheck++;
+         /* do not check for new mail in inc fldrs and fall through */ 
+             
  	    /*------- Standard commands ------*/
            default:
  	    whereis_pos.row = 0;
***************
*** 8380,8385 ****
--- 8418,8424 ----
  
      } /* End of while() -- loop executing commands */
  
+ end:
      ps_global->redrawer	= NULL;	/* next statement makes this invalid! */
      zero_scroll_text();		/* very important to zero out on return!!! */
      scroll_state(SS_FREE);
diff -rc pine4.64/pine/newmail.c pine4.64.incoming/pine/newmail.c
*** pine4.64/pine/newmail.c	Thu Jan 13 16:43:13 2005
--- pine4.64.incoming/pine/newmail.c	Mon Oct 30 22:42:35 2006
***************
*** 48,53 ****
--- 48,55 ----
  
  #include "headers.h"
  
+ static long incoming_folders_new_mail  = 0L;
+ 
  
  /*
   * Internal prototypes
***************
*** 840,845 ****
--- 842,849 ----
  
      if(subject)
        fs_give((void **) &subject);
+ 
+     ps_global->skip_ifcheck = 0;
  }
  
  
***************
*** 1095,1100 ****
--- 1099,1109 ----
  	if(m && sp_flagged(m, SP_LOCKED))
  	  sp_set_mail_since_cmd(m, 0L);
      }
+ 
+     if (incoming_folders_new_mail > 0L){
+ 	icon_text(NULL, IT_NEWMAIL);
+ 	incoming_folders_new_mail = 0L;
+     }
  }
  
  
***************
*** 1299,1301 ****
--- 1308,1602 ----
      }
  }
  #endif
+ 
+ #define ADD_FLD_MSG(m, F, j) \
+ 	{\
+ 	     strcat((m),"\"");\
+              strcat((m),FLDR_NAME((F)));\
+ 	     strcat((m),"\"");\
+ 	     (F)->notified = 1;\
+ 	     if (j)\
+ 	       strcat((m),", ");\
+ 	}
+ #define MSG(n)  (((n) + 30 > SIZEOF_20KBUF) ? message : tmp_20k_buf)
+ #define CODE()  ((command == MC_FORCECHECK) ? 1 : ((newflds > 0) ? -1 : 1))
+ #define NMVAR()  ((command == MC_FORCECHECK) ? nflds : \
+ 			newflds > 0 ? newflds : nflds)
+ 
+ /*  Check for new mail in incoming folders */
+ int 
+ new_mail_incfolder(state,command)
+    struct pine *state;
+    int command;
+ {
+  char *message   = NULL;
+  int  i, j;
+  int  checks, indx, f_indx, first_check;
+  int  nflds = 0, tlflds = 0, newflds = 0, tflds, newmailininbox; 
+  int  save_state, last_fld_chkd = state->last_folder_checked;
+  int  tcp_query_timeout = state->tcp_query_timeout;
+  int  tcp_open_timeout = 30;
+  int  offset = F_ON(F_ENABLE_FAST_RECENT, state) ? 1 : 0;
+  static int index = -1;
+  static int check_started = 0;
+  time_t start_check, this_check, total_check;
+  static time_t now, old = 0;
+  FOLDER_S *f;
+ 
+    if (F_OFF(F_ENABLE_INCOMING,ps_global) 
+ 	|| F_OFF(F_ENABLE_INCOMING_CHECK,ps_global)
+ 	|| (state->inc_check_rule == IC_MAN
+ 		&& command != MC_FORCECHECK)
+ 	|| (state->inc_check_rule == IC_MAN_AUTO
+ 		&& check_started == 0 && command != MC_FORCECHECK))
+       return -1;
+ 
+    if ((!state->force_check_now) || (state->checking_incfld)){
+        state->force_check_now = 1;      /* I'll be back, but wait a moment */
+         return -1;
+    }
+ 
+    now = time(0);
+    if ((old != 0) && (command != MC_FORCECHECK) && 
+       (now - old < timeo))
+ 	return -1;
+ 
+    state->checking_incfld = 1;		/* point of no return */
+    check_started = 1;			/* checks have already started */
+    ps_global->mm_log_error = 0;		/* turn off display of errors */
+    ps_global->noshow_error = 1;
+ 
+    if(state->VAR_TCPOPENTIMEO)
+       (void)SVAR_TCP_OPEN(state, tcp_open_timeout, tmp_20k_buf);
+    mail_parameters(NULL, SET_OPENTIMEOUT, (void *)(long)state->incfld_timeout);
+ 
+    save_state = ps_global->in_init_seq;
+    state->in_init_seq = 0;	/* force output of cue during check */
+    check_cue_display("+");	/* Show something to indicate delay */
+    MoveCursor(state->ttyo->screen_rows -FOOTER_ROWS(state),0);
+    fflush(stdout);
+    state->tcp_query_timeout = state->incfld_timeout;
+ 
+    if(state->context_current){
+      MAILSTREAM *nxtstrm = NULL;
+      long        rec, tot, fslctd;
+      int	 opstrm, updated;
+      CONTEXT_S  *ctxt = sp_context(sp_inbox_stream());
+ 
+     /* Look for the Incoming folder collections, Normally the incoming folders
+      * collection is the first collection, but just to be sure, we back up to
+      * the beginning and go forward from there to try to find it.
+      */
+ 
+      if (!ctxt){
+ 	ctxt =  state->context_current;
+ 	while (1){
+ 	  if (ctxt->prev)
+ 	     ctxt = ctxt->prev;
+ 	  else
+ 	     break;
+ 	}
+ 	while (1){
+ 	  if (ctxt->use & CNTXT_INCMNG)
+ 	     break;
+ 	  else
+ 	     ctxt = ctxt->next;
+ 	}
+      }
+ 
+      tflds    = folder_total(FOLDERS(ctxt));
+ 
+      /* Someone removed a folder between checks among other things */
+      if(index >= tflds) 
+ 	index = -1;
+ 
+      if(index < folder_index(state->inbox_name, ctxt, FI_FOLDER)
+ 			+ offset)
+ 	index = folder_index(state->inbox_name, ctxt, FI_FOLDER) + offset;
+ 
+      f_indx = index;
+      if(state->first_folder_checked != f_indx)
+ 	state->refresh_list |= IF_REFRESH_WEAK;
+      state->first_folder_checked = f_indx;
+      this_check = total_check = 0;
+      for(checks = 0; checks < tflds - offset
+ 	    && (f = folder_entry(index, FOLDERS(ctxt)))
+ 	    && !f->isdir; index++, checks++){
+ 
+ 	if(checks == 0)
+ 	  first_check = 0;
+ 
+ 	if(F_OFF(F_ENABLE_INCOMING_RECHECK,state)
+         	&& (command != MC_FORCECHECK)
+ 		&& (f->last_check_time != 0)	/* do a full first check */
+ 		&& total_check > state->incfld_timeout)
+ 	  break;
+ 
+ 	state->login_time = 0;		/* modified in mm_login */
+ 	start_check = time(0);
+         if(F_ON(F_ENABLE_INCOMING_RECHECK, state)
+ 	   || (command == MC_FORCECHECK)
+ 	   || (f->last_check_time == 0)	/* first call? */
+ 	   || (start_check - f->last_check_time > f->last_check_length*timeo)){
+ 	  if(first_check == 0){
+ 	     first_check++;
+ 	     state->first_folder_checked = index;
+ 	  }
+ 	  state->last_folder_checked = index;
+ 	  fslctd = next_folder_check(&nxtstrm, ctxt, &rec, &tot, f, &opstrm);
+ 	  this_check = time(0) - start_check - state->login_time;
+ 	  f->last_check_time = start_check + this_check + state->login_time;
+ 	  f->interesting = fslctd;
+ 	  f->opstrm = opstrm;
+ 	  f->last_check_length = this_check + 1;
+ 	  state->refresh_list |= f->skipped ? IF_REFRESH_WEAK : IF_REFRESH_NONE;  
+ 	  f->skipped = 0;
+ 	}
+ 	else{
+ 	  fslctd = f->interesting;
+ 	  opstrm = f->opstrm;
+ 	  rec = f->recent;	/* use the old data */
+ 	  tot = f->messages;
+ 	  this_check = 0;
+ 	  state->refresh_list |= f->skipped ? IF_REFRESH_NONE : IF_REFRESH_WEAK;
+ 	  f->skipped = 1;
+ 	}
+ 	total_check += this_check;
+ 
+ 	if(fslctd && !strcmp(FLDR_NAME(f), state->cur_folder) 
+ 		  && !state->in_fld_list)
+ 	   fslctd = 0L;
+ 
+ 	updated = (rec != f->recent || tot != f->messages);
+ 	if ((f->recent + f->messages == 0L && updated) 
+ 	    || (((!opstrm && updated) || (!f->notified && opstrm  && updated))
+ 		 && fslctd))
+ 	   state->refresh_list |= IF_REFRESH_STRONG;
+ 
+ 	f->messages    = tot;
+ 	f->recent      = rec;
+ 
+         if (!offset && f->countrecent == 0L && fslctd)
+ 	   fslctd = 0L;
+ 
+         if (fslctd){	/* this folder contains new mail */
+ 	   state->refresh_list |= f->selected ? IF_REFRESH_NONE : IF_REFRESH_STRONG;
+ 	   f->selected = 1;
+ 	   tlflds += strlen(FLDR_NAME(f)) + 4;
+ 	   f->new_mail = 1;
+ 	   if(!f->notified){
+ 	      newflds++;
+ 	      f->new_mail = (command == MC_FORCECHECK) ? 1 : -1;
+ 	   }
+ 	   nflds++;
+         }
+ 	else{
+ 	   if (f->selected)
+ 	     state->refresh_list |= f->user_selected ? IF_REFRESH_NONE : IF_REFRESH_STRONG;
+ 	   if (f->notified)
+ 	     f->selected = f->user_selected ? 1 : 0;
+ 	   f->notified = f->new_mail = 0;	/* reset */
+ 	}
+ 	if(index == tflds - 1)
+ 	   index = folder_index(state->inbox_name, ctxt, FI_FOLDER)
+ 			+ offset - 1;
+      }
+ 
+      if(nxtstrm)
+ 	pine_mail_close(nxtstrm);
+ 
+      if(ps_global->last_folder_checked != last_fld_chkd)
+ 	state->refresh_list |= IF_REFRESH_WEAK;
+ 
+      state->mm_log_error = 1;	/* turn display of errors back on */
+      state->noshow_error = 0;
+ 
+      if(nflds == 0){
+         if (command == MC_FORCECHECK && state->VAR_INCOMING_FOLDERS_CHECK)
+ 	   q_status_message(SM_ORDER, 0, 2,
+                    "There are NO new messages in your Incoming Folders");
+      }
+      else{  /* nflds > 0 */
+ 	newmailininbox = 0;
+ 	if (tlflds + 30 > SIZEOF_20KBUF)
+ 	   message = (char *) fs_get((tlflds + 30)*sizeof(char));
+ 	if(newflds > 0)
+ 	  state->refresh_list |= IF_REFRESH_STRONG;
+         strcpy(MSG(tlflds),"New mail in folder");
+         strcat(MSG(tlflds),(NMVAR() > 1) ? "s " : " ");
+ 	for(i = 0, j = 0, indx = f_indx; 
+ 	   j < checks && (f = folder_entry(indx, FOLDERS(ctxt))); j++, indx++){
+ 	   if(f->new_mail == CODE()){
+ 	      if(NMVAR() > 1){
+ 		ADD_FLD_MSG(MSG(tlflds), f, (i < (NMVAR() - 2)) ? 1 : 0);
+ 		if(i == NMVAR() - 2)
+ 		   strcat(MSG(tlflds)," and ");
+ 	      }
+ 	      else
+ 		ADD_FLD_MSG(MSG(tlflds), f, 0);
+ 	      f->new_mail = 1;
+ 	      if(indx == 0)
+ 		newmailininbox++;
+ 	      if(++i == NMVAR())
+ 		break;
+ 	   }
+ 	   if(indx == tflds - 1)
+ 	     indx = folder_index(state->inbox_name, ctxt,FI_FOLDER)+ offset - 1;
+ 	}
+ 	if (newflds > 0 || command == MC_FORCECHECK){
+ 	    int use_buf = 0;
+ 	    if(strlen(MSG(tlflds)) >= state->ttyo->screen_cols - 2){
+ 	       strcpy(tmp_20k_buf,
+ 			"You have NEW mail in your Incoming Folders");
+ 	       use_buf++;
+ 	    }
+ 	    if(newmailininbox == 0 || command == MC_FORCECHECK){
+ 	       q_status_message(command == MC_FORCECHECK
+ 				? SM_ORDER : SM_ASYNC | SM_DING, 0, 
+ 			     command == MC_FORCECHECK
+ 				? 2 : 60, 
+ 			     use_buf ? tmp_20k_buf : MSG(tlflds));
+ 	       icon_text(use_buf ? tmp_20k_buf : MSG(tlflds), IT_NEWMAIL);
+ 	    }
+         }
+ 	if (message)
+ 	   fs_give((void **)&message);
+      } /* end of nflds > 0 */
+    }
+    state->checking_incfld = 0;
+    check_cue_display(" ");		/* Erase the "+" added before */  
+    state->in_init_seq = save_state;	/* restore original value     */
+    MoveCursor(state->ttyo->screen_rows -FOOTER_ROWS(state),0);
+    incoming_folders_new_mail = nflds;
+ 
+    old = time(0);
+    state->delay = total_check;
+    state->tcp_query_timeout = tcp_query_timeout;
+    mail_parameters(NULL, SET_OPENTIMEOUT, (void *)(long)tcp_open_timeout);
+ 
+    return nflds;
+ }
+ 
+ 
+ char *
+ new_mail_in_open_stream(stream, rec, tot)
+   MAILSTREAM *stream;
+   long *rec;
+   long *tot;
+ {
+    long excluded;
+ 
+    if((excluded = any_lflagged(sp_msgmap(stream), MN_EXLD))){
+       *tot = stream->nmsgs - excluded;
+       if(tot)
+          *rec = count_flagged(stream, F_RECENT);
+       else
+          *rec = 0L;
+    }
+    else{
+       *tot = stream->nmsgs;
+       *rec = stream->recent;
+    }
+ 
+    return *rec ? STREAMNAME(stream) : NULL;
+ }
diff -rc pine4.64/pine/osdep/termin.gen pine4.64.incoming/pine/osdep/termin.gen
*** pine4.64/pine/osdep/termin.gen	Wed Dec  1 10:56:45 2004
--- pine4.64.incoming/pine/osdep/termin.gen	Mon Oct 30 22:42:35 2006
***************
*** 1039,1045 ****
      }
  
      if(firsttime) {
! 	firsttime = 0;
  	if(ps_global->in_init_seq) {
  	    ps_global->in_init_seq = 0;
  	    ps_global->save_in_init_seq = 0;
--- 1039,1045 ----
      }
  
      if(firsttime) {
! 	firsttime = ps_global->checking_incfld ? (char) 1 : 0;
  	if(ps_global->in_init_seq) {
  	    ps_global->in_init_seq = 0;
  	    ps_global->save_in_init_seq = 0;
diff -rc pine4.64/pine/other.c pine4.64.incoming/pine/other.c
*** pine4.64/pine/other.c	Mon Sep 12 15:04:25 2005
--- pine4.64.incoming/pine/other.c	Mon Oct 30 22:42:35 2006
***************
*** 1674,1679 ****
--- 1674,1680 ----
  	       || vtmp == &ps->vars[V_TCPREADWARNTIMEO]
  	       || vtmp == &ps->vars[V_TCPWRITEWARNTIMEO]
  	       || vtmp == &ps->vars[V_TCPQUERYTIMEO]
+ 	       || vtmp == &ps->vars[V_INCFLDTIMEO]
  	       || vtmp == &ps->vars[V_RSHOPENTIMEO]
  	       || vtmp == &ps->vars[V_SSHOPENTIMEO]
  	       || vtmp == &ps->vars[V_USERINPUTTIMEO]
***************
*** 1799,1804 ****
--- 1800,1806 ----
  	   v == &ps->vars[V_FCC_RULE] ||
  	   v == &ps->vars[V_GOTO_DEFAULT_RULE] ||
  	   v == &ps->vars[V_INCOMING_STARTUP] ||
+ 	   v == &ps->vars[V_INCOMING_RULE] ||
  	   v == &ps->vars[V_PRUNING_RULE] ||
  	   v == &ps->vars[V_REOPEN_RULE] ||
  	   v == &ps->vars[V_THREAD_DISP_STYLE] ||
***************
*** 1828,1833 ****
--- 1830,1837 ----
        rulefunc = goto_rules;
      else if(v == &ps->vars[V_INCOMING_STARTUP])
        rulefunc = incoming_startup_rules;
+     else if(v == &ps->vars[V_INCOMING_RULE])
+       rulefunc = incoming_check_rules;
      else if(v == startup_ptr)
        rulefunc = startup_rules;
      else if(v == &ps->vars[V_PRUNING_RULE])
***************
*** 1999,2004 ****
--- 2003,2009 ----
        case V_TCPREADWARNTIMEO :
        case V_TCPWRITEWARNTIMEO :
        case V_TCPQUERYTIMEO :
+       case V_INCFLDTIMEO :
        case V_RSHCMD :
        case V_RSHPATH :
        case V_RSHOPENTIMEO :
***************
*** 7440,7445 ****
--- 7445,7452 ----
  	return(h_config_nntp_server);
        case V_INBOX_PATH :
  	return(h_config_inbox_path);
+       case V_INCOMING_FOLDERS_CHECK :
+         return(h_config_check_inc_fld);
        case V_PRUNED_FOLDERS :
  	return(h_config_pruned_folders);
        case V_DEFAULT_FCC :
***************
*** 7524,7529 ****
--- 7531,7538 ----
  	return(h_config_tcp_writewarn_timeo);
        case V_TCPQUERYTIMEO :
  	return(h_config_tcp_query_timeo);
+       case V_INCFLDTIMEO :
+ 	return(h_config_inc_fld_timeo);
        case V_RSHOPENTIMEO :
  	return(h_config_rsh_open_timeo);
        case V_SSHOPENTIMEO :
***************
*** 7606,7611 ****
--- 7615,7622 ----
  	return(h_config_goto_default);
        case V_INCOMING_STARTUP:
  	return(h_config_inc_startup);
+       case V_INCOMING_RULE:
+ 	return(h_config_inc_rule);
        case V_PRUNING_RULE:
  	return(h_config_pruning_rule);
        case V_REOPEN_RULE:
***************
*** 8056,8061 ****
--- 8067,8076 ----
  	    lowrange = 5;
  	    hirange  = 1000;
  	}
+ 	else if((*cl)->var == &ps->vars[V_INCFLDTIMEO]){
+ 	    lowrange = 2;
+ 	    hirange  = 60;
+ 	}
  	else if((*cl)->var == &ps->vars[V_TCPWRITEWARNTIMEO] ||
  	        (*cl)->var == &ps->vars[V_RSHOPENTIMEO] ||
  	        (*cl)->var == &ps->vars[V_SSHOPENTIMEO] ||
***************
*** 12861,12866 ****
--- 12876,12887 ----
  	  if(ps->VAR_TCPQUERYTIMEO && SVAR_TCP_QUERY(ps, val, tmp_20k_buf))
  	    q_status_message(SM_ORDER, 3, 5, tmp_20k_buf);
      }
+     else if(var == &ps->vars[V_INCFLDTIMEO]){
+ 	val = 5;
+ 	if(!revert)
+ 	  if(ps->VAR_INCFLDTIMEO && SVAR_TCP_QUERY(ps, val, tmp_20k_buf))
+ 	    q_status_message(SM_ORDER, 3, 5, tmp_20k_buf);
+     }
      else if(var == &ps->vars[V_RSHOPENTIMEO]){
  	val = 15;
  	if(!revert)
***************
*** 12902,12907 ****
--- 12923,12933 ----
  	      fs_give((void **)&ps->vars[V_OPER_DIR].main_user_val.p);
  	}
      }
+     else if(var == &ps->vars[V_INCOMING_FOLDERS_CHECK] &&
+ 	    F_OFF(F_ENABLE_FAST_RECENT, ps)){
+ 	ps->force_check_now = 1;
+ 	new_mail_incfolder(ps, MC_FORCECHECK);  /* yes, update it now */
+     }
      else if(var == &ps->vars[V_MAILCHECK]){
  	timeo = 15;
  	if(SVAR_MAILCHK(ps, timeo, tmp_20k_buf)){
diff -rc pine4.64/pine/pine.c pine4.64.incoming/pine/pine.c
*** pine4.64/pine/pine.c	Mon Sep 12 15:04:25 2005
--- pine4.64.incoming/pine/pine.c	Mon Oct 30 22:45:49 2006
***************
*** 87,92 ****
--- 87,93 ----
  /*
   * Internal prototypes
   */
+ int     sp_add_status PROTO((MAILSTREAM *));
  int     sp_add PROTO((MAILSTREAM *, int));
  int     sp_nusepool_notperm PROTO((void));
  void    sp_delete PROTO((MAILSTREAM *));
***************
*** 264,269 ****
--- 265,272 ----
      ps_global->sort_types[8]   = SortScore;
      ps_global->sort_types[9]   = SortThread;
      ps_global->sort_types[10]   = EndofList;
+     ps_global->force_check_now = 1;
+     ps_global->delay	       = 1;
      ps_global->atmts           = (ATTACH_S *) fs_get(sizeof(ATTACH_S));
      ps_global->atmts_allocated = 1;
      ps_global->atmts->description = NULL;
***************
*** 372,377 ****
--- 375,381 ----
      mail_parameters(NULL, SET_TIMEOUT, (void *) pine_tcptimeout);
      /* could be TO_BAIL_THRESHOLD, 15 seems more appropriate for now */
      pine_state->tcp_query_timeout = 15;
+     pine_state->incfld_timeout	  =  5;
  
      mail_parameters(NULL, SET_SENDCOMMAND, (void *) pine_imap_cmd_happened);
      mail_parameters(NULL, SET_FREESTREAMSPAREP, (void *) sp_free_callback);
***************
*** 3181,3187 ****
  {
      int quit = 0;
  
!     dprint(1, (debugfile, "\n\n    ---- QUIT SCREEN ----\n"));    
  
      if(F_ON(F_CHECK_MAIL_ONQUIT,ps_global)
         && new_mail(1, VeryBadTime, NM_STATUS_MSG | NM_DEFER_SORT) > 0
--- 3185,3192 ----
  {
      int quit = 0;
  
!     dprint(1, (debugfile, "\n\n    ---- QUIT SCREEN ----\n"));
!     ps_global->in_pico = 1; /* we are leaving anyway */
  
      if(F_ON(F_CHECK_MAIL_ONQUIT,ps_global)
         && new_mail(1, VeryBadTime, NM_STATUS_MSG | NM_DEFER_SORT) > 0
***************
*** 3328,3333 ****
--- 3333,3339 ----
      dprint(7, (debugfile, "goodnight_gracey: sp_end\n"));
      ps_global->noshow_error = 1;
      sp_end();
+     sp_status_end();
  
      /* after sp_end, which might call a filter */
      completely_done_with_adrbks();
***************
*** 4164,4186 ****
  	   || !strucmp(canonical_name(mb_n.host), mb_s.host))
         && (!mb_n.port || mb_n.port == mb_s.port)
         && mb_n.anoflag == stream->anonymous
!        && (struncmp(mb_n.service, "imap", 4)
! 	    ? 1
! 	    : (strcmp(imap_host(stream), ".NO-IMAP-CONNECTION.")
! 	       && ((mb_n.user && *mb_n.user &&
! 	            mb_s.user && !strcmp(mb_n.user, mb_s.user))
! 		   ||
! 		   ((!mb_n.user || !*mb_n.user)
! 		    && mb_s.user
! 		    && ((ps_global->VAR_USER_ID
! 		         && !strcmp(ps_global->VAR_USER_ID, mb_s.user))
! 		        ||
! 		        (!ps_global->VAR_USER_ID
! 			 && ps_global->ui.login[0]
! 		         && !strcmp(ps_global->ui.login, mb_s.user))))
! 		   ||
! 		   (!((mb_n.user && *mb_n.user) || (mb_s.user && *mb_s.user))
! 		    && stream->anonymous))))){
  	dprint(7, (debugfile, "same_stream: name->%s == stream->%s: yes\n",
  	       name ? name : "?",
  	       (stream && stream->mailbox) ? stream->mailbox : "NULL"));
--- 4170,4190 ----
  	   || !strucmp(canonical_name(mb_n.host), mb_s.host))
         && (!mb_n.port || mb_n.port == mb_s.port)
         && mb_n.anoflag == stream->anonymous
!        && ((mb_n.user && *mb_n.user &&
! 	    mb_s.user && !strcmp(mb_n.user, mb_s.user))
! 	   ||
! 	   ((!mb_n.user || !*mb_n.user)
! 	    && mb_s.user
! 	    && ((ps_global->VAR_USER_ID
! 		 && !strcmp(ps_global->VAR_USER_ID, mb_s.user))
! 		||
! 		(!ps_global->VAR_USER_ID
! 		 && ps_global->ui.login[0]
! 		 && !strcmp(ps_global->ui.login, mb_s.user))))
! 	   ||
! 	   (!((mb_n.user && *mb_n.user) || (mb_s.user && *mb_s.user))
! 	    && stream->anonymous))
!        && (struncmp(mb_n.service, "imap", 4) ? 1 : strcmp(imap_host(stream), ".NO-IMAP-CONNECTION."))){
  	dprint(7, (debugfile, "same_stream: name->%s == stream->%s: yes\n",
  	       name ? name : "?",
  	       (stream && stream->mailbox) ? stream->mailbox : "NULL"));
***************
*** 6337,6342 ****
--- 6341,6431 ----
      return(NULL);
  }
  
+ MAILSTREAM *
+ sp_stream_status_get(mailbox)
+     char         *mailbox;
+ {
+   int         i;
+   MAILSTREAM *m = NULL;
+ 
+   for(i = 0; i < ps_global->s_pool_status.nstream; i++){
+       m = ps_global->s_pool_status.streams[i];
+       if(m && same_stream(mailbox, m) && pine_mail_ping(m))
+ 	 return m;
+   }
+   return NULL;
+ }
+ 
+ void
+ sp_status_end()
+ {
+     int         i;
+     MAILSTREAM *m;
+ 
+     for(i = 0; i < ps_global->s_pool_status.nstream; i++){
+ 	m = ps_global->s_pool_status.streams[i];
+ 	if(m)
+ 	  pine_mail_actually_close(m);
+     }
+ 
+     if(ps_global->s_pool_status.streams)
+       fs_give((void **) &ps_global->s_pool_status.streams);
+ 
+     ps_global->s_pool_status.nstream = 0;
+ }
+ 
+ int
+ sp_add_status(stream)
+     MAILSTREAM *stream;
+ {
+     int i, slot = -1;
+     MAILSTREAM *m;
+ 
+     if(!stream)
+ 	return -1;
+ 
+     for(i = 0; i < ps_global->s_pool_status.nstream; i++){
+ 	m = ps_global->s_pool_status.streams[i];
+ 	if(m == stream){
+ 	    slot = i;
+ 	    return 0;
+ 	}
+     }
+ 
+     for(i = 0; i < ps_global->s_pool_status.nstream; i++){
+ 	m = ps_global->s_pool_status.streams[i];
+ 	if(!m){
+ 	    slot = i;
+ 	    break;
+ 	}
+     }
+ 
+     if(slot < 0){
+ 	slot = ps_global->s_pool_status.nstream++;
+ 	if(ps_global->s_pool_status.streams){
+ 	    fs_resize((void **) &ps_global->s_pool_status.streams,
+ 		      ps_global->s_pool_status.nstream *
+ 		        sizeof(*ps_global->s_pool_status.streams));
+ 	    ps_global->s_pool_status.streams[slot] = NULL;
+ 	}
+ 	else{
+ 	    ps_global->s_pool_status.streams =
+ 		(MAILSTREAM **) fs_get(ps_global->s_pool_status.nstream *
+ 				 sizeof(*ps_global->s_pool_status.streams));
+ 	    memset(ps_global->s_pool_status.streams, 0,
+ 		   ps_global->s_pool_status.nstream *
+ 		    sizeof(*ps_global->s_pool_status.streams));
+ 	}
+     }
+ 
+     if(slot >= 0 && slot < ps_global->s_pool_status.nstream){
+ 	ps_global->s_pool_status.streams[slot] = stream;
+ 	return 0;
+     }
+     else
+ 	return -1;
+ }
+ 
  
  void
  sp_end()
diff -rc pine4.64/pine/pine.h pine4.64.incoming/pine/pine.h
*** pine4.64/pine/pine.h	Thu Sep 15 17:39:42 2005
--- pine4.64.incoming/pine/pine.h	Mon Oct 30 22:48:36 2006
***************
*** 232,237 ****
--- 232,240 ----
  #ifndef DF_INCOMING_STARTUP
  #define DF_INCOMING_STARTUP	"first-unseen"
  #endif
+ #ifndef DF_INCOMING_RULE
+ #define DF_INCOMING_RULE	"automatic"
+ #endif
  #ifndef DF_PRUNING_RULE
  #define DF_PRUNING_RULE		"ask-ask"
  #endif
***************
*** 620,625 ****
--- 623,629 ----
  		, V_SMTP_SERVER
  		, V_NNTP_SERVER
  		, V_INBOX_PATH
+              	, V_INCOMING_FOLDERS_CHECK
  		, V_ARCHIVED_FOLDERS
  		, V_PRUNED_FOLDERS
  		, V_DEFAULT_FCC
***************
*** 644,649 ****
--- 648,654 ----
  		, V_FLD_SORT_RULE
  		, V_GOTO_DEFAULT_RULE
  		, V_INCOMING_STARTUP
+ 		, V_INCOMING_RULE
  		, V_PRUNING_RULE
  		, V_REOPEN_RULE
  		, V_THREAD_DISP_STYLE
***************
*** 724,729 ****
--- 729,735 ----
  		, V_TCPREADWARNTIMEO
  		, V_TCPWRITEWARNTIMEO
  		, V_TCPQUERYTIMEO
+ 		, V_INCFLDTIMEO
  		, V_RSHCMD
  		, V_RSHPATH
  		, V_RSHOPENTIMEO
***************
*** 841,846 ****
--- 847,854 ----
  #define VAR_INBOX_PATH		     vars[V_INBOX_PATH].current_val.p
  #define GLO_INBOX_PATH		     vars[V_INBOX_PATH].global_val.p
  #define VAR_INCOMING_FOLDERS	     vars[V_INCOMING_FOLDERS].current_val.l
+ #define VAR_INCOMING_FOLDERS_CHECK   vars[V_INCOMING_FOLDERS_CHECK].current_val.p
+ #define GLO_INCOMING_FOLDERS_CHECK   vars[V_INCOMING_FOLDERS_CHECK].global_val.p
  #define VAR_FOLDER_SPEC		     vars[V_FOLDER_SPEC].current_val.l
  #define GLO_FOLDER_SPEC		     vars[V_FOLDER_SPEC].global_val.l
  #define VAR_NEWS_SPEC		     vars[V_NEWS_SPEC].current_val.l
***************
*** 1033,1038 ****
--- 1041,1047 ----
  #define VAR_TCPREADWARNTIMEO	     vars[V_TCPREADWARNTIMEO].current_val.p
  #define VAR_TCPWRITEWARNTIMEO	     vars[V_TCPWRITEWARNTIMEO].current_val.p
  #define VAR_TCPQUERYTIMEO	     vars[V_TCPQUERYTIMEO].current_val.p
+ #define VAR_INCFLDTIMEO		     vars[V_INCFLDTIMEO].current_val.p
  #define VAR_RSHOPENTIMEO	     vars[V_RSHOPENTIMEO].current_val.p
  #define VAR_RSHPATH		     vars[V_RSHPATH].current_val.p
  #define VAR_RSHCMD		     vars[V_RSHCMD].current_val.p
***************
*** 1045,1050 ****
--- 1054,1061 ----
  #define VAR_BROWSER		     vars[V_BROWSER].current_val.l
  #define VAR_INCOMING_STARTUP	     vars[V_INCOMING_STARTUP].current_val.p
  #define GLO_INCOMING_STARTUP	     vars[V_INCOMING_STARTUP].global_val.p
+ #define VAR_INCOMING_RULE	     vars[V_INCOMING_RULE].current_val.p
+ #define GLO_INCOMING_RULE	     vars[V_INCOMING_RULE].global_val.p
  #define VAR_PRUNING_RULE	     vars[V_PRUNING_RULE].current_val.p
  #define GLO_PRUNING_RULE	     vars[V_PRUNING_RULE].global_val.p
  #define VAR_REOPEN_RULE		     vars[V_REOPEN_RULE].current_val.p
***************
*** 1184,1189 ****
--- 1195,1202 ----
  	F_DISABLE_PIPES_IN_TEMPLATES,
  	F_ATTACHMENTS_IN_REPLY,
  	F_ENABLE_INCOMING,
+ 	F_ENABLE_INCOMING_CHECK,
+ 	F_ENABLE_INCOMING_RECHECK,
  	F_NO_NEWS_VALIDATION,
  	F_QUELL_EXTRA_POST_PROMPT,
  	F_DISABLE_TAKE_LASTFIRST,
***************
*** 1547,1552 ****
--- 1560,1572 ----
  #define	IS_NOTSET			7	/* for reset version */
  
  /*
+  * Incoming check rules
+  */
+ #define	IC_AUTO		0
+ #define	IC_MAN_AUTO	1
+ #define	IC_MAN		2
+ 
+ /*
   * Pruning rules. If these grow, widen pruning_rule.
   */
  #define	PRUNE_ASK_AND_ASK		0
***************
*** 1830,1835 ****
--- 1850,1859 ----
  #define	SVAR_TCP_QUERY(ps, n, e) strtoval((ps)->VAR_TCPQUERYTIMEO, 	  \
  					 &(n), 5, 30000, 0, (e),	  \
  					"Tcp-Query-Timeout")
+ #define SVAR_INCFLDQUERY(ps, n, e) strtoval((ps)->VAR_INCFLDTIMEO,	\
+                                         &(n), 2, 60, 0, (e),		\
+                                        "Inc-fld-timeout")
+ 
  #define	SVAR_RSH_OPEN(ps, n, e)	strtoval((ps)->VAR_RSHOPENTIMEO, 	  \
  					 &(n), 5, 30000, 0, (e),	  \
  					"Rsh-Open-Timeout")
***************
*** 2571,2580 ****
--- 2595,2616 ----
      unsigned        hasnochildren:1;            /* known not to have children */
      unsigned	    scanned:1;			/* scanned by c-client	      */
      unsigned	    selected:1;			/* selected by user	      */
+     unsigned	    user_selected:1;		/* selected by user (not Pine)*/
      unsigned	    subscribed:1;		/* selected by user	      */
      unsigned long   varhash;			/* hash of var for incoming   */
      unsigned long   uidvalidity;		/* only for #move folder      */
      unsigned long   uidnext;			/* only for #move folder      */
+     time_t	    last_check_time;		/* elapsed time in last check */
+     int		    notified;			/* notified the change?	      */
+     int		    new_mail;			/* folder has new mail	      */
+     int		    last_check_length;		/* elapsed time in last check */
+     int		    skipped;			/* skipped test?	      */
+     int		    opstrm;			/* open stream?		      */
+     long	    interesting;		/* result of last test	      */
+     long	    origrecent;			/* # recent messages in stream*/
+     long	    countrecent;		/* # recent messages displayed*/
+     long	    recent;			/* # recent messages adjusted */
+     long	    messages;			/* # messages		      */
      char	   *nickname;			/* folder's short name        */
      char	    name[1];			/* folder's name              */
  } FOLDER_S;
***************
*** 2997,3002 ****
--- 3033,3040 ----
  /*
   * Some standard Key/Command Bindings 
   */
+ #define MC_IFAUTOCHECK	820
+ #define MC_FORCECHECK	821
  #define	NULL_MENU	{NULL, NULL, {MC_NONE}, KS_NONE}
  #define	HELP_MENU	{"?", "Help", \
  			 {MC_HELP, 2, {'?',ctrl('G')}}, \
***************
*** 4217,4223 ****
      RFC2369DATA_S   data[MLCMD_MAXDATA];
  } RFC2369_S;
  
! 
  
  /*----------------------------------------------------------------------
     This structure sort of takes the place of global variables or perhaps
--- 4255,4263 ----
      RFC2369DATA_S   data[MLCMD_MAXDATA];
  } RFC2369_S;
  
! #define IF_REFRESH_NONE		0x00
! #define IF_REFRESH_WEAK		0x01
! #define IF_REFRESH_STRONG	0x10
  
  /*----------------------------------------------------------------------
     This structure sort of takes the place of global variables or perhaps
***************
*** 4243,4248 ****
--- 4283,4289 ----
      CONTEXT_S   *context_last;		/* most recently open context    */
  
      SP_S         s_pool;		/* stream pool */
+     SP_S         s_pool_status;		/* stream pool */
  
      char         inbox_name[MAXFOLDER+1];
      char         pine_pre_vers[10];	/* highest version previously run */
***************
*** 4254,4259 ****
--- 4295,4311 ----
  
      char         cur_folder[MAXPATH+1];
      char         last_unambig_folder[MAXPATH+1];
+     int          refresh_list;
+     int          in_pico;
+     int		 in_fld_list;
+     int		 force_check_now;
+     int          checking_incfld;
+     int          incfld_timeout;
+     int		 last_folder_checked;
+     int		 first_folder_checked;
+     int		 skip_ifcheck;
+     time_t	 login_time;
+     int		 delay;
      ATTACH_S    *atmts;
      int          atmts_allocated;
      int	         remote_abook_validity;	/* minutes, -1=never, 0=only on opens */
***************
*** 4287,4292 ****
--- 4339,4345 ----
      unsigned     titlebar_color_style:3;
      unsigned	 fld_sort_rule:3;
      unsigned	 inc_startup_rule:3;
+     unsigned	 inc_check_rule:2;
      unsigned	 pruning_rule:3;
      unsigned	 reopen_rule:4;
      unsigned	 goto_default_rule:3;
***************
*** 4610,4621 ****
--- 4663,4679 ----
  char	   *folder_is_nick PROTO((char *, void *, int));
  char	   *next_folder PROTO((MAILSTREAM **, char *, char *,CONTEXT_S *,
  			       long *, int *));
+ int	    next_folder_check PROTO((MAILSTREAM **, CONTEXT_S *, long *, long *,
+ 			       FOLDER_S *, int *));
  void	    init_inbox_mapping PROTO((char *, CONTEXT_S *));
  int	    news_build PROTO((char *, char **, char **, BUILDER_ARG *, int *));
  char	   *news_group_selector PROTO((char **));
  void	    free_newsgrp_cache PROTO(());
  char	   *context_edit_screen PROTO((struct pine *, char *, char *,
  				       char *, char *, char *));
+ void	    update_incoming_folder_data PROTO((MAILSTREAM *, CONTEXT_S *));
+ FOLDER_S   *incoming_folder_data PROTO((MAILSTREAM *, CONTEXT_S *));
+ int	    need_folder_report PROTO ((char *));
  SELECTED_S *new_selected PROTO((void));
  void	    free_selected PROTO((SELECTED_S **));
  int	    add_new_folder PROTO((CONTEXT_S *, EditWhich, int, char *, size_t,
***************
*** 4700,4705 ****
--- 4758,4764 ----
  NAMEVAL_S  *titlebar_col_style PROTO((int));
  NAMEVAL_S  *fld_sort_rules PROTO((int));
  NAMEVAL_S  *incoming_startup_rules PROTO((int));
+ NAMEVAL_S  *incoming_check_rules PROTO((int));
  NAMEVAL_S  *startup_rules PROTO((int));
  NAMEVAL_S  *pruning_rules PROTO((int));
  NAMEVAL_S  *reopen_rules PROTO((int));
***************
*** 4960,4965 ****
--- 5019,5026 ----
  void	    check_point_change PROTO((MAILSTREAM *));
  void	    reset_check_point PROTO((MAILSTREAM *));
  void	    zero_new_mail_count PROTO((void));
+ int	    new_mail_incfolder PROTO((struct pine *, int));
+ char	   *new_mail_in_open_stream PROTO((MAILSTREAM *, long *, long *));
  int	    changes_to_checkpoint PROTO((MAILSTREAM *));
  void	    close_newmailfifo PROTO((void));
  void	    init_newmailfifo PROTO((char *));
***************
*** 5145,5156 ****
--- 5206,5219 ----
  int         sp_flagged PROTO((MAILSTREAM *, unsigned long));
  void        sp_mark_stream_dead PROTO((MAILSTREAM *));
  MAILSTREAM *sp_stream_get PROTO((char *, unsigned long));
+ MAILSTREAM *sp_stream_status_get PROTO((char *));
  int         sp_a_locked_stream_is_dead PROTO((void));
  int         sp_a_locked_stream_changed PROTO((void));
  MAILSTREAM *sp_inbox_stream PROTO((void));
  void        sp_cleanup_dead_streams PROTO((void));
  int         sp_nremote_permlocked PROTO((void));
  void        sp_end PROTO((void));
+ void        sp_status_end PROTO((void));
  
  /*-- reply.c --*/
  void	    reply PROTO((struct pine *, ACTION_S *));
diff -rc pine4.64/pine/pine.hlp pine4.64.incoming/pine/pine.hlp
*** pine4.64/pine/pine.hlp	Wed Sep 28 10:56:29 2005
--- pine4.64.incoming/pine/pine.hlp	Mon Oct 30 22:42:36 2006
***************
*** 18964,18969 ****
--- 18964,18986 ----
  be combined with the other fields if you'd like.
  
  <End of help on this topic>
+ ====== h_config_check_inc_fld ======
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: incoming-folders-to-check</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: incoming-folders-to-check</H1>
+ <P>
+ if you set this option and <A HREF="h_config_enable_check_incoming">
+ enable-check-incoming-folders</A> then you can use this option to write a space
+ separate list of incoming folders where you want new mail to be
+ checked. If you want all your incoming folders to be checked just write a
+ "*" as the value for this option.
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ======= h_address_format =======
  <HTML>
  <HEAD>
***************
*** 21953,21958 ****
--- 21970,22007 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_inc_fld_timeo =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: inc-fld-timeout</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: inc-fld-timeout</H1>
+ 
+ When Pine is checking for new mail in an external incoming folder, and the
+ amount of time specified in this variable has elapsed without Pine being
+ able to connect to the server holding that mailbox, Pine will drop the
+ connection to that server and continue checking for new mail in other
+ incoming folders, if any.
+ 
+ <P>
+ Observe that Pine will not print an error message in this case, but it
+ will silently drop the connection. If your connections are fast setting
+ this to a large value will not cause you any problem, but if your
+ connections are slow setting this to a small value will make Pine speed
+ checking for new mail, although it is possible that not all of your
+ incoming folders will be checked for new mail.
+ 
+ <P>
+ The default is 5 seconds, which is also the minimum and the maximum is 60.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_incoming_folders =====
  <HTML>
  <HEAD>
***************
*** 24519,24524 ****
--- 24568,24618 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_inc_rule =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Incoming-Check-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Incoming-Check-Rule</H1>
+ 
+ This value affects Pine's behavior when starting Pine. It determines
+ how and when Pine will check for new mail in your incoming folders. The
+ default value is &quot;automatic&quot;.
+ 
+ <P>
+ The three possible values for this option are:
+ 
+ <DL>
+ <DT>automatic</DT>
+ <DD>This is the default. When this is selected the first check for new
+ mail will be done when Pine is starting up and you either go to the
+ INDEX or FOLDER LIST screens.
+ </DD>
+ 
+ <DT>automatic-after-first-manual-check</DT>
+ <DD>Similar to the default, but no check is done until you force the first
+ one by pressing CTRL-H. All checks are automatic after the first one. Observe
+ that this feature does not work once an automatic check has been done.
+ </DD>
+ 
+ <DT>manual-only</DT>
+ <DD>This forces Pine to do only manual checks. This will probably speed
+ Pine, since checks will  only happen when they are forced by pressing CTRL-H.
+ </DD>
+ </DL>
+ 
+ <P>
+ If you just want to stop Pine from checking in one folder, then simply
+ select that folder. Checks on that folder will be skipped.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_browser =====
  <HTML>
  <HEAD>
***************
*** 25593,25598 ****
--- 25687,25767 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_enable_check_incoming ======
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: enable-check-incoming-folders</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: enable-check-incoming-folders</H1>
+ If you have enabled <A HREF="h_config_enable_incoming">incoming
+ folders</A> then setting this feature allows you to check for new mail in
+ these. A message stating that new mail was received and in which folders
+ will be written in the screen. You can decide which incoming folders you
+ want to check for new mail, and the list of them has to be entered in the
+ setting <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>.
+ 
+ <P> If you have the option 
+ <A HREF="h_config_fast_recent">enable-fast-recent-test</A>
+ <B>disabled</B>, but have this feature enabled, then a full report on the
+ total number of messages, and the number of new messages in the folder is
+ printed in the <A HREF="h_folder_maint">FOLDER LIST</A> screen 
+ for each folder listed in the variable 
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>. The report for each
+ folder is made in the format
+ 
+ <P>
+ folder-name [Number of new messages/Number of messages in the folder]
+ 
+ <P>
+ If an incoming folder is not listed in the variable
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>, then only 
+ the name of the folder and no other report is made about that folder.
+ 
+ <P>
+ Other important features related to this feature are:
+ <OL>
+ <LI><A HREF="h_config_enable_recheck_incoming">recheck-all-incoming-folders</A>,
+ which allows you to decide if you want to check all folders in every check.
+ <LI><A HREF="h_config_inc_rule">incoming-check-rule</A>, which determines
+ how and when Pine will check for new mail in your incoming folders.
+ </OL>
+ 
+ <P>
+ <UL>
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL>
+ </BODY>
+ </HTML>
+ ====== h_config_enable_recheck_incoming ======
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: recheck-all-incoming-folders</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: recheck-all-incoming-folders</H1>
+ If you have enabled <A HREF="h_config_enable_incoming">incoming folders</A>
+ and <A HREF="h_config_enable_check_incoming">enable-check-incoming-folder</A>
+ then setting this feature will force Pine to check <B>all</B> incoming folders
+ for new mail in every check. The normal behavior (when this feature
+ is not enabled) is that Pine will skip checking for new mail in folders
+ where it already found new mail, or it will skip folders where checking
+ for new mail takes too long. This is done to speed checking for new mail.
+ 
+ <P>
+ One of the problems that the default behavior causes is if you use two 
+ programs (or copies of Pine) to access the same incoming folders, because 
+ Pine will not realize that new mail does not exist in one folder where it 
+ already reported new mail, but was opened with the other client. Setting 
+ this feature will cause Pine to recheck all folders all the time. In this 
+ way Pine will know for sure which folders <B>DO</B> contain new mail.
+ 
+ <P>
+ <UL>
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL>
+ </BODY>
+ </HTML>
  ====== h_config_attach_in_reply ======
  <HTML>
  <HEAD>
***************
*** 26192,26197 ****
--- 26361,26393 ----
  <A HREF="h_config_tab_uses_unseen">&quot;Tab-Uses-Unseen-For-Next-Folder&quot;</A>
  is turned on, then the present feature will have no effect.
  
+ <P> When this feature is <B>disabled</B>, and the feature 
+ <A HREF="h_config_enable_check_incoming">enable-check-incoming-folders</A>
+ is enabled, then a full report of the number of messages and number of
+ new messages in each incoming folder listed in the option
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A> is made. This
+ report is printed in the <A HREF="h_folder_maint">FOLDER LIST</A> screen. The 
+ report is given in the form
+ 
+ <P>
+ folder-name [Number of New Messages/Number of messages in the folder]
+ 
+ <P> If an incoming-folder is not listed in the variable 
+ <A HREF="h_config_check_inc_fld">incoming-folders-to-check</A>, no check for
+ that folder is made, so only the folder name, and no other information is
+ printed about that folder.
+ 
+ <P> If this feature is enabled and the feature 
+ <A HREF="h_config_enable_recheck_incoming">recheck-all-incoming-folders</A>
+ is disabled, then selecting a folder will cancel further checks on that
+ folder. This is useful if checks to a particular incoming folder are slow
+ and want to be avoided (until the folder is unselected and a new cycle of
+ checks is done) without changing the list of folders to be checked.
+ Selecting a folder in order to avoid checks for new mail does not work in
+ other cases, since it is either explicitly requested this way or because
+ it is necessary to update the count of new and total number of messages of
+ every requested folder.
+ 
  <P>
  <UL>   
  <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
diff -rc pine4.64/pine/send.c pine4.64.incoming/pine/send.c
*** pine4.64/pine/send.c	Mon Sep 12 15:04:25 2005
--- pine4.64.incoming/pine/send.c	Mon Oct 30 22:42:36 2006
***************
*** 4276,4284 ****
--- 4276,4287 ----
  	/* turn off user input timeout when in composer */
  	saved_user_timeout = ps_global->hours_to_timeout;
  	ps_global->hours_to_timeout = 0;
+ 	ps_global->in_pico = 1; /* in */
  	dprint(1, (debugfile, "\n  ---- COMPOSER ----\n"));
  	editor_result = pico(pbf);
+ 	ps_global->force_check_now = 0; /* do not check incoming folders now */
  	dprint(4, (debugfile, "... composer returns (0x%x)\n", editor_result));
+ 	ps_global->in_pico = 0; /* out */
  	ps_global->hours_to_timeout = saved_user_timeout;
  
  #if	defined(DOS) && !defined(_WINDOWS)
diff -rc pine4.64/pine/signals.c pine4.64.incoming/pine/signals.c
*** pine4.64/pine/signals.c	Thu Nov  4 14:31:46 2004
--- pine4.64.incoming/pine/signals.c	Mon Oct 30 22:42:36 2006
***************
*** 673,679 ****
  
  		add_review_message(buf, -1);
  	    }
! 	    else{
  		q_status_message(SM_ORDER, 0, 1, progress);
  
  		/*
--- 673,679 ----
  
  		add_review_message(buf, -1);
  	    }
! 	    else if (!ps_global->checking_incfld){
  		q_status_message(SM_ORDER, 0, 1, progress);
  
  		/*
***************
*** 694,700 ****
      }
  
      /* set alarm */
!     if(F_OFF(F_DISABLE_ALARM, ps_global))
        alarm(seconds);
  
      return(retval);
--- 694,700 ----
      }
  
      /* set alarm */
!     if(F_OFF(F_DISABLE_ALARM, ps_global) && (!ps_global->checking_incfld))
        alarm(seconds);
  
      return(retval);
***************
*** 733,738 ****
--- 733,739 ----
  		left  = slots_used - 4 - right;
  		sprintf(progress, "%s |%*s100%%%*s|",
  		    busy_message, left, "", right, "");
+ 		if (!ps_global->checking_incfld)
  		q_status_message(SM_ORDER,
  		    message_pri>=2 ? max(message_pri,3) : 0,
  		    message_pri+2, progress);
***************
*** 740,745 ****
--- 741,747 ----
  	    else{
  		sprintf(progress, "%s%*sDONE", busy_message,
  		    DISPLAY_CHARS_COLS - 4 + 1, "");
+ 		if (!ps_global->checking_incfld)
  		q_status_message(SM_ORDER,
  		    message_pri>=2 ? max(message_pri,3) : 0,
  		    message_pri+2, progress);
